using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using FastEnumUtility.Generators.Internals;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace FastEnumUtility.Generators;



/// <summary>
/// Provides code generation of IFastEnumBooster&lt;T&gt; implementation.
/// </summary>
[Generator(LanguageNames.CSharp)]
public sealed class FastEnumBoosterGenerator : IIncrementalGenerator
{
    #region IIncrementalGenerator
    /// <inheritdoc/>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var typeDeclarations
            = context.SyntaxProvider.ForAttributeWithMetadataName
            (
                fullyQualifiedMetadataName: "FastEnumUtility.FastEnumAttribute`1",
                predicate: static (node, cancellationToken) =>
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    return node
                        is ClassDeclarationSyntax
                        or StructDeclarationSyntax
                        or RecordDeclarationSyntax;
                },
                transform: static (context, cancellationToken) =>
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    return context;
                }
            );
        var parseOptions = context.ParseOptionsProvider;
        var source = typeDeclarations.Combine(parseOptions);

        context.RegisterSourceOutput(source, static (context, source) =>
        {
            var syntax = source.Left;
            var options = (CSharpParseOptions)source.Right;
            var param = new GenerateParameters(syntax, options);

            var diagnostic = Diagnose(param);
            if (diagnostic is not null)
            {
                context.ReportDiagnostic(diagnostic);
                return;
            }

            var code = Generate(param);
            context.AddSource(param.FileName, code);
        });
    }
    #endregion


    #region Helpers
    private static Diagnostic? Diagnose(GenerateParameters param)
    {
        var containerType = param.ContainerType;
        var enumType = param.EnumType;

        //--- partial type only
        if (!containerType.IsPartial)
        {
            var descriptor = DiagnosticDescriptorProvider.MustBePartial;
            var location = containerType.SyntaxNode.Identifier.GetLocation();
            var args = containerType.TypeName;
            return Diagnostic.Create(descriptor, location, args);
        }

        //--- Disallow nested type
        if (containerType.IsNested)
        {
            var descriptor = DiagnosticDescriptorProvider.MustNotBeNested;
            var location = containerType.SyntaxNode.Identifier.GetLocation();
            var args = containerType.TypeName;
            return Diagnostic.Create(descriptor, location, args);
        }

        //--- Allow public or internal only
        if (!enumType.IsPublicOrInternal)
        {
            var descriptor = DiagnosticDescriptorProvider.MustBePublicOrInternal;
            var location = enumType.SyntaxNode.GetLocation();
            var args = enumType.SyntaxNode.GetText();
            return Diagnostic.Create(descriptor, location, args);
        }

        //--- Generic type argument must be enum type
        if (!enumType.IsEnum)
        {
            var descriptor = DiagnosticDescriptorProvider.MustBeEnumType;
            var location = enumType.SyntaxNode.GetLocation();
            var args = enumType.SyntaxNode.GetText();
            return Diagnostic.Create(descriptor, location, args);
        }

        return null;
    }


    private static string Generate(GenerateParameters param)
    {
        var sb = new StringBuilder();

        //--- header
        sb.AppendLine("""
            // <auto-generated>
            // This .cs file is generated by FastEnum source generator.
            // </auto-generated>
            #nullable enable

            using System;
            using System.Globalization;
            using System.Runtime.CompilerServices;
            using FastEnumUtility;
            """);

        //--- start namespace
        if (!param.ContainerType.IsGlobalNamespace)
        {
            sb.AppendLine($"""

                namespace {param.ContainerType.Namespace};
                """);
        }

        //--- start class
        sb.AppendLine($$"""

            partial {{param.ContainerType.TypeKind}} {{param.ContainerType.TypeName}} : IFastEnumBooster<{{param.EnumType.TypeName}}>
            {
                #region IFastEnumBooster<T>
            """);

        //--- .GetName()
        {
            sb.AppendLine($$"""
                    /// <inheritdoc/>
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    static string? IFastEnumBooster<{{param.EnumType.TypeName}}>.GetName({{param.EnumType.TypeName}} value)
                    {
                        return value switch
                        {
                """);
            foreach (var field in param.EnumType.DistinctedFields)
            {
                sb.AppendLine($"            {param.EnumType.TypeName}.{field.Name} => nameof({param.EnumType.TypeName}.{field.Name}),");
            }
            sb.AppendLine($$"""
                            _ => null,
                        };
                    }
                """);
        }

        //--- .IsDefined(TEnum)
        {
            sb.AppendLine($$"""

                    /// <inheritdoc/>
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    static bool IFastEnumBooster<{{param.EnumType.TypeName}}>.IsDefined({{param.EnumType.TypeName}} value)
                    {
                        return value switch
                        {
                """);
            foreach (var field in param.EnumType.DistinctedFields)
            {
                sb.AppendLine($"            {param.EnumType.TypeName}.{field.Name} => true,");
            }
            sb.AppendLine($$"""
                            _ => false,
                        };
                    }
                """);
        }

        //--- .IsDefined(ReadOnlySpan<char>)
        {
            sb.AppendLine($$"""

                    /// <inheritdoc/>
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    static bool IFastEnumBooster<{{param.EnumType.TypeName}}>.IsDefined(ReadOnlySpan<char> name)
                    {
                """);
            foreach (var field in param.EnumType.Fields)
            {
                sb.AppendLine($$"""
                            if (name.Equals(nameof({{param.EnumType.TypeName}}.{{field.Name}}), StringComparison.Ordinal))
                                return true;

                    """);
            }
            sb.AppendLine($$"""
                        return false;
                    }
                """);
        }

        //--- .TryParseName()
        {
            sb.AppendLine($$"""

                    /// <inheritdoc/>
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    static bool IFastEnumBooster<{{param.EnumType.TypeName}}>.TryParseName(ReadOnlySpan<char> text, bool ignoreCase, out {{param.EnumType.TypeName}} result)
                    {
                        return ignoreCase
                            ? caseInsensitive(text, out result)
                            : caseSensitive(text, out result);


                        #region Local Functions
                        [MethodImpl(MethodImplOptions.AggressiveInlining)]
                        static bool caseSensitive(ReadOnlySpan<char> text, out {{param.EnumType.TypeName}} result)
                        {
                            switch (text)
                            {
                """);
            foreach (var field in param.EnumType.Fields)
            {
                sb.AppendLine($$"""
                                    case nameof({{param.EnumType.TypeName}}.{{field.Name}}):
                                        result = {{param.EnumType.TypeName}}.{{field.Name}};
                                        return true;

                    """);
            }
            sb.AppendLine($$"""
                                default:
                                    result = default;
                                    return false;
                            }
                        }


                        [MethodImpl(MethodImplOptions.AggressiveInlining)]
                        static bool caseInsensitive(ReadOnlySpan<char> text, out {{param.EnumType.TypeName}} result)
                        {
                """);
            foreach (var field in param.EnumType.Fields)
            {
                sb.AppendLine($$"""
                                if (text.Equals(nameof({{param.EnumType.TypeName}}.{{field.Name}}), StringComparison.OrdinalIgnoreCase))
                                {
                                    result = {{param.EnumType.TypeName}}.{{field.Name}};
                                    return true;
                                }
                    """);
            }
            sb.AppendLine($$"""
                            result = default;
                            return false;
                        }
                        #endregion
                    }
                """);
        }

        //--- end class
        sb.AppendLine("""
                #endregion
            }
            """);

        //--- ok
        return sb.ToString();
    }
    #endregion


    #region Nested Types
    private sealed class GenerateParameters
    {
        #region Properties
        public LanguageVersion LanguageVersion { get; }
        public string FileName { get; }
        public ContainerTypeMetadata ContainerType { get; }
        public EnumTypeMetadata EnumType { get; }
        #endregion


        #region Constructors
        public GenerateParameters(GeneratorAttributeSyntaxContext context, CSharpParseOptions parseOptions)
        {
            var containerNode = (TypeDeclarationSyntax)context.TargetNode;
            var containerSymbol = (INamedTypeSymbol)context.TargetSymbol;
            var enumNode = getEnumNode(containerNode);
            var enumSymbol = getEnumSymbol(context);

            this.LanguageVersion = parseOptions.LanguageVersion;
            this.FileName = createFileName(containerSymbol);
            this.ContainerType = new(containerNode, containerSymbol);
            this.EnumType = new(enumNode, enumSymbol);


            #region Local Functions
            static string createFileName(ISymbol symbol)
            {
                var typeName = symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                var escaped = typeName.Replace("global::", "").Replace("<", "_").Replace(">", "_");
                return $"{escaped}.FastEnumBooster.g.cs";
            }


            static TypeSyntax getEnumNode(MemberDeclarationSyntax syntax)
            {
                var attributes = syntax.AttributeLists.SelectMany(static x => x.Attributes);
                foreach (var attr in attributes)
                {
                    var generic = getGenericNameSyntax(attr.Name);
                    if (generic is null)
                        continue;

                    if (generic.Identifier.Text is not ("FastEnum" or "FastEnumAttribute"))
                        continue;

                    var @enum = generic.TypeArgumentList.Arguments.First();
                    return @enum;
                }
                throw new InvalidOperationException("FastEnumAttribute<T> is not annotated.");
            }


            static GenericNameSyntax? getGenericNameSyntax(NameSyntax syntax)
            {
                if (syntax is QualifiedNameSyntax qualified)  // [global::FastEnumUtility.FastEnum<TEnum>]
                    return getGenericNameSyntax(qualified.Right);

                if (syntax is GenericNameSyntax generic)  // [FastEnum<TEnum>]
                    return generic;

                return null;
            }


            static INamedTypeSymbol getEnumSymbol(GeneratorAttributeSyntaxContext context)
            {
                var attr = context.Attributes.First(static x => x.AttributeClass!.MetadataName is "FastEnumAttribute`1");
                return (INamedTypeSymbol)attr.AttributeClass!.TypeArguments[0];
            }
            #endregion
        }
        #endregion
    }



    private sealed class ContainerTypeMetadata
    {
        #region Properties
        public TypeDeclarationSyntax SyntaxNode { get; }
        public INamedTypeSymbol TypeSymbol { get; }
        public bool IsGlobalNamespace { get; }
        public bool IsGeneric { get; }
        public bool IsPartial { get; }
        public bool IsNested { get; }
        public string Namespace { get; }
        public string TypeKind { get; }
        public string TypeName { get; }
        #endregion


        #region Constructors
        public ContainerTypeMetadata(TypeDeclarationSyntax syntax, INamedTypeSymbol symbol)
        {
            this.SyntaxNode = syntax;
            this.TypeSymbol = symbol;
            this.IsGlobalNamespace = symbol.ContainingNamespace.IsGlobalNamespace;
            this.IsGeneric = symbol.IsGenericType;
            this.IsPartial = syntax.Modifiers.Any(static x => x.IsKind(SyntaxKind.PartialKeyword));
            this.IsNested = syntax.Parent is TypeDeclarationSyntax;
            this.Namespace = symbol.ContainingNamespace.ToDisplayString();
            this.TypeKind = toTypeKind(symbol);
            this.TypeName = symbol.Name;


            #region Local Functions
            static string toTypeKind(INamedTypeSymbol symbol)
            {
                return (symbol.IsRecord, symbol.IsValueType) switch
                {
                    (true, true) => "record struct",
                    (true, false) => "record class",
                    (false, true) => "struct",
                    (false, false) => "class",
                };
            }
            #endregion
        }
        #endregion
    }



    private sealed class EnumTypeMetadata
    {
        #region Properties
        public TypeSyntax SyntaxNode { get; }
        public INamedTypeSymbol TypeSymbol { get; }
        public bool IsPublicOrInternal { get; }
        public bool IsEnum { get; }
        public string TypeName { get; }
        public string UnderlyingType { get; }
        public IReadOnlyList<IFieldSymbol> Fields { get; }
        public IReadOnlyList<IFieldSymbol> DistinctedFields { get; }
        #endregion


        #region Constructors
        public EnumTypeMetadata(TypeSyntax syntax, INamedTypeSymbol symbol)
        {
            this.SyntaxNode = syntax;
            this.TypeSymbol = symbol;
            this.IsPublicOrInternal = isPublicOrInternal(symbol);
            this.IsEnum = symbol.TypeKind is TypeKind.Enum;
            this.TypeName = symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            this.UnderlyingType = symbol.EnumUnderlyingType?.ToDisplayString() ?? "int";
            this.Fields = symbol.GetMembers().OfType<IFieldSymbol>().ToArray();
#pragma warning disable RS1024  // Use 'SymbolEqualityComparer' when comparing symbols
            // note:
            //  - In this case, where a custom IEqualityComparer<T> is being utilized, the RS1024 warning is deemed inappropriate and is recognized as a bug in Microsoft.CodeAnalysis.CSharp.
            //  - Although this issue has been rectified in version 4.6.0, the use of version 4.4.0 does not present any functional problems.
            //  - Consequently, we have opted to address this by suppressing the warning.
            this.DistinctedFields = this.Fields.Distinct(new FieldSymbolComparer()).ToArray();
#pragma warning restore RS1024


            #region Local Functions
            static bool isPublicOrInternal(INamedTypeSymbol symbol)
            {
                // note:
                //  - For file-local types, accessibility is set to 'Friend' (= Internal).
                //  - Therefore, it is necessary to determine separately that it is a file-local types.

                if (symbol.IsFileLocal)
                    return false;

                return symbol.DeclaredAccessibility
                    is Accessibility.Public
                    or Accessibility.Internal;
            }
            #endregion
        }
        #endregion


        #region Nested Types
        private sealed class FieldSymbolComparer : IEqualityComparer<IFieldSymbol>
        {
            /// <inheritdoc/>
            public bool Equals(IFieldSymbol x, IFieldSymbol y)
                => EqualityComparer<object>.Default.Equals(x.ConstantValue!, y.ConstantValue!);


            /// <inheritdoc/>
            public int GetHashCode(IFieldSymbol obj)
                => EqualityComparer<object>.Default.GetHashCode(obj.ConstantValue!);
        }
        #endregion
    }
    #endregion
}
