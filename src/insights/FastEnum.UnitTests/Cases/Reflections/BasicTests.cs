// <auto-generated>
// This .cs file is generated by T4 template. Don't change it. Change the .tt file instead.
// </auto-generated>
#nullable enable

using System;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Text;
using FastEnumUtility.UnitTests.Models;
using FluentAssertions;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace FastEnumUtility.UnitTests.Cases.Reflections;



/// <summary>
/// Provides unit tests for enum based on <see cref="sbyte"/> type.
/// </summary>
[TestClass]
public sealed class SByteTests
{
    [TestMethod]
    public void GetUnderlyingType()
        => FastEnum.GetUnderlyingType<SByteEnum>().Should().Be<sbyte>();


    [TestMethod]
    public void GetValues()
    {
        var expect = Enum.GetValues<SByteEnum>();
        var actual = FastEnum.GetValues<SByteEnum>();
        actual.Should().BeEquivalentTo(expect);
    }


    [TestMethod]
    public void GetNames()
    {
        var expect = Enum.GetNames<SByteEnum>();
        var actual = FastEnum.GetNames<SByteEnum>();
        actual.Should().BeEquivalentTo(expect);
    }


    [TestMethod]
    public void GetName()
    {
        //--- defined value
        {
            const SByteEnum defined = SByteEnum.MinValue;
            var expect = Enum.GetName(defined);
            var actual = FastEnum.GetName(defined);
            actual.Should().NotBeNull();
            actual.Should().BeEquivalentTo(expect);
        }
        //--- undefined value
        {
            const SByteEnum undefined = (SByteEnum)123;
            var expect = Enum.GetName(undefined);
            var actual = FastEnum.GetName(undefined);
            actual.Should().BeNull();
            actual.Should().BeEquivalentTo(expect);
        }
    }


    [TestMethod]
    public void GetMembers()
    {
        var expect
            = Enum.GetNames<SByteEnum>()
            .Select(static name =>
            {
                var value = Enum.Parse<SByteEnum>(name);
                var nameUtf8 = Encoding.UTF8.GetBytes(name);
                var fieldInfo = typeof(SByteEnum).GetField(name);
                return (value, name, nameUtf8, fieldInfo);
            })
            .ToArray();
        var actual = FastEnum.GetMembers<SByteEnum>();

        actual.Length.Should().Be(expect.Length);
        for (var i = 0; i < expect.Length; i++)
        {
            var a = actual[i];
            var e = expect[i];
            a.Value.Should().Be(e.value);
            a.Name.Should().Be(e.name);
            a.NameUtf8.Should().Equal(e.nameUtf8);
            a.FieldInfo.Should().Be(e.fieldInfo);

            var (name, value) = a;
            value.Should().Be(e.value);
            name.Should().Be(e.name);
        }
    }


    [TestMethod]
    public void GetMember()
    {
        //--- defined value
        {
            const SByteEnum defined = SByteEnum.MinValue;
            var expect = getMember(defined);
            var actual = FastEnum.GetMember(defined)!;

            actual.Should().NotBeNull();
            actual.Value.Should().Be(expect.value);
            actual.Name.Should().Be(expect.name);
            actual.NameUtf8.Should().Equal(expect.nameUtf8);
            actual.FieldInfo.Should().Be(expect.fieldInfo);

            var (name, value) = actual;
            value.Should().Be(expect.value);
            name.Should().Be(expect.name);
        }
        //--- undefined value
        {
            const SByteEnum undefined = (SByteEnum)123;
            var actual = FastEnum.GetMember(undefined);
            actual.Should().BeNull();
        }

        #region Local Functions
        static (T value, string name, byte[] nameUtf8, FieldInfo fieldInfo) getMember<T>(T value)
            where T : struct, Enum
        {
            var name = Enum.GetName<T>(value)!;
            var nameUtf8 = Encoding.UTF8.GetBytes(name);
            var fieldInfo = typeof(T).GetField(name)!;
            return (value, name, nameUtf8, fieldInfo);
        }
        #endregion
    }


    [TestMethod]
    public void GetMinValue()
    {
        var min = FastEnum.GetMinValue<SByteEnum>();
        min.Should().NotBeNull();
        min.Should().Be(SByteEnum.MinValue);
    }


    [TestMethod]
    public void GetMaxValue()
    {
        var max = FastEnum.GetMaxValue<SByteEnum>();
        max.Should().NotBeNull();
        max.Should().Be(SByteEnum.MaxValue);
    }


    [TestMethod]
    public void IsEmpty()
        => FastEnum.IsEmpty<SByteEnum>().Should().Be(false);


    [TestMethod]
    public void IsContinuous()
        => FastEnum.IsContinuous<SByteEnum>().Should().Be(false);


    [TestMethod]
    public void IsFlags()
        => FastEnum.IsFlags<SByteEnum>().Should().Be(false);


    [TestMethod]
    public void IsDefined()
    {
        //--- IsDefined(TEnum)
        FastEnum.IsDefined<SByteEnum>(SByteEnum.MinValue).Should().BeTrue();
        FastEnum.IsDefined<SByteEnum>(SByteEnum.Zero).Should().BeTrue();
        FastEnum.IsDefined<SByteEnum>(SByteEnum.MaxValue).Should().BeTrue();
        FastEnum.IsDefined<SByteEnum>((SByteEnum)123).Should().BeFalse();

        //--- Extension methods
        SByteEnum.MinValue.IsDefined().Should().BeTrue();
        SByteEnum.Zero.IsDefined().Should().BeTrue();
        SByteEnum.MaxValue.IsDefined().Should().BeTrue();

        //--- IsDefined(ReadOnlySpan<char>)
        FastEnum.IsDefined<SByteEnum>(nameof(SByteEnum.MinValue)).Should().BeTrue();
        FastEnum.IsDefined<SByteEnum>(nameof(SByteEnum.Zero)).Should().BeTrue();
        FastEnum.IsDefined<SByteEnum>(nameof(SByteEnum.MaxValue)).Should().BeTrue();
        FastEnum.IsDefined<SByteEnum>("123").Should().BeFalse();
        FastEnum.IsDefined<SByteEnum>("minvalue").Should().BeFalse();
    }


    [TestMethod]
    public void Parse()
    {
        var parameters = new[]
        {
            (value: SByteEnum.MinValue, name: nameof(SByteEnum.MinValue), valueString: ((sbyte)SByteEnum.MinValue).ToString(CultureInfo.InvariantCulture)),
            (value: SByteEnum.Zero,     name: nameof(SByteEnum.Zero),     valueString: ((sbyte)SByteEnum.Zero).ToString(CultureInfo.InvariantCulture)),
            (value: SByteEnum.MaxValue, name: nameof(SByteEnum.MaxValue), valueString: ((sbyte)SByteEnum.MaxValue).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.Parse<SByteEnum>(x.name).Should().Be(x.value);
            FluentActions.Invoking(() => FastEnum.Parse<SByteEnum>(x.name.ToLower(CultureInfo.InvariantCulture))).Should().Throw<ArgumentException>();
            FluentActions.Invoking(() => FastEnum.Parse<SByteEnum>(x.name.ToUpper(CultureInfo.InvariantCulture))).Should().Throw<ArgumentException>();
            FastEnum.Parse<SByteEnum>(x.valueString).Should().Be(x.value);
            FastEnum.Parse<SByteEnum>(x.valueString.ToLower(CultureInfo.InvariantCulture)).Should().Be(x.value);
            FastEnum.Parse<SByteEnum>(x.valueString.ToUpper(CultureInfo.InvariantCulture)).Should().Be(x.value);
        }
        FluentActions.Invoking(static () => FastEnum.Parse<SByteEnum>((string?)null, true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<SByteEnum>("")).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<SByteEnum>(" ")).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<SByteEnum>("ABCDE")).Should().Throw<ArgumentException>();
        FastEnum.Parse<SByteEnum>("123").Should().Be((SByteEnum)123);
    }


    [TestMethod]
    public void ParseIgnoreCase()
    {
        var parameters = new[]
        {
            (value: SByteEnum.MinValue, name: nameof(SByteEnum.MinValue), valueString: ((sbyte)SByteEnum.MinValue).ToString(CultureInfo.InvariantCulture)),
            (value: SByteEnum.Zero,     name: nameof(SByteEnum.Zero),     valueString: ((sbyte)SByteEnum.Zero).ToString(CultureInfo.InvariantCulture)),
            (value: SByteEnum.MaxValue, name: nameof(SByteEnum.MaxValue), valueString: ((sbyte)SByteEnum.MaxValue).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.Parse<SByteEnum>(x.name, true).Should().Be(x.value);
            FastEnum.Parse<SByteEnum>(x.name.ToLower(CultureInfo.InvariantCulture), true).Should().Be(x.value);
            FastEnum.Parse<SByteEnum>(x.name.ToUpper(CultureInfo.InvariantCulture), true).Should().Be(x.value);
            FastEnum.Parse<SByteEnum>(x.valueString).Should().Be(x.value);
            FastEnum.Parse<SByteEnum>(x.valueString.ToLower(CultureInfo.InvariantCulture), true).Should().Be(x.value);
            FastEnum.Parse<SByteEnum>(x.valueString.ToUpper(CultureInfo.InvariantCulture), true).Should().Be(x.value);
        }
        FluentActions.Invoking(static () => FastEnum.Parse<SByteEnum>((string?)null, true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<SByteEnum>("", true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<SByteEnum>(" ", true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<SByteEnum>("ABCDE", true)).Should().Throw<ArgumentException>();
        FastEnum.Parse<SByteEnum>("123").Should().Be((SByteEnum)123);
    }


    [TestMethod]
    public void TryParse()
    {
        var parameters = new[]
        {
            (value: SByteEnum.MinValue, name: nameof(SByteEnum.MinValue), valueString: ((sbyte)SByteEnum.MinValue).ToString(CultureInfo.InvariantCulture)),
            (value: SByteEnum.Zero,     name: nameof(SByteEnum.Zero),     valueString: ((sbyte)SByteEnum.Zero).ToString(CultureInfo.InvariantCulture)),
            (value: SByteEnum.MaxValue, name: nameof(SByteEnum.MaxValue), valueString: ((sbyte)SByteEnum.MaxValue).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.TryParse<SByteEnum>(x.name, out var r1).Should().BeTrue();
            r1.Should().Be(x.value);

            FastEnum.TryParse<SByteEnum>(x.name.ToLower(CultureInfo.InvariantCulture), out var _).Should().BeFalse();
            FastEnum.TryParse<SByteEnum>(x.name.ToUpper(CultureInfo.InvariantCulture), out var _).Should().BeFalse();

            FastEnum.TryParse<SByteEnum>(x.valueString, out var r2).Should().BeTrue();
            r2.Should().Be(x.value);

            FastEnum.TryParse<SByteEnum>(x.valueString.ToLower(CultureInfo.InvariantCulture), out var r3).Should().BeTrue();
            r3.Should().Be(x.value);

            FastEnum.TryParse<SByteEnum>(x.valueString.ToUpper(CultureInfo.InvariantCulture), out var r4).Should().BeTrue();
            r4.Should().Be(x.value);
        }
        FastEnum.TryParse<SByteEnum>((string?)null, out var _).Should().BeFalse();
        FastEnum.TryParse<SByteEnum>("", out var _).Should().BeFalse();
        FastEnum.TryParse<SByteEnum>(" ", out var _).Should().BeFalse();
        FastEnum.TryParse<SByteEnum>("ABCDE", out var _).Should().BeFalse();
        FastEnum.TryParse<SByteEnum>("123", out var r).Should().BeTrue();
        r.Should().Be((SByteEnum)123);
    }


    [TestMethod]
    public void TryParseIgnoreCase()
    {
        var parameters = new[]
        {
            (value: SByteEnum.MinValue, name: nameof(SByteEnum.MinValue), valueString: ((sbyte)SByteEnum.MinValue).ToString(CultureInfo.InvariantCulture)),
            (value: SByteEnum.Zero,     name: nameof(SByteEnum.Zero),     valueString: ((sbyte)SByteEnum.Zero).ToString(CultureInfo.InvariantCulture)),
            (value: SByteEnum.MaxValue, name: nameof(SByteEnum.MaxValue), valueString: ((sbyte)SByteEnum.MaxValue).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.TryParse<SByteEnum>(x.name, true, out var r1).Should().BeTrue();
            r1.Should().Be(x.value);

            FastEnum.TryParse<SByteEnum>(x.name.ToLower(CultureInfo.InvariantCulture), true, out var r2).Should().BeTrue();
            r2.Should().Be(x.value);

            FastEnum.TryParse<SByteEnum>(x.name.ToUpper(CultureInfo.InvariantCulture), true, out var r3).Should().BeTrue();
            r3.Should().Be(x.value);

            FastEnum.TryParse<SByteEnum>(x.valueString, true, out var r4).Should().BeTrue();
            r4.Should().Be(x.value);

            FastEnum.TryParse<SByteEnum>(x.valueString.ToLower(CultureInfo.InvariantCulture), true, out var r5).Should().BeTrue();
            r5.Should().Be(x.value);

            FastEnum.TryParse<SByteEnum>(x.valueString.ToUpper(CultureInfo.InvariantCulture), true, out var r6).Should().BeTrue();
            r6.Should().Be(x.value);
        }
        FastEnum.TryParse<SByteEnum>((string?)null, true, out var _).Should().BeFalse();
        FastEnum.TryParse<SByteEnum>("", true, out var _).Should().BeFalse();
        FastEnum.TryParse<SByteEnum>(" ", true, out var _).Should().BeFalse();
        FastEnum.TryParse<SByteEnum>("ABCDE", true, out var _).Should().BeFalse();
        FastEnum.TryParse<SByteEnum>("123", true, out var r).Should().BeTrue();
        r.Should().Be((SByteEnum)123);
    }


    [TestMethod]
    public void ToMember()
    {
        var value = SByteEnum.MaxValue;
        var name = nameof(SByteEnum.MaxValue);
        var nameUtf8 = Encoding.UTF8.GetBytes(name);
        var member = value.ToMember()!;
        var info = typeof(SByteEnum).GetField(name);

        member.Should().NotBeNull();
        member.Name.Should().Be(name);
        member.NameUtf8.Should().Equal(nameUtf8);
        member.Value.Should().Be(value);
        member.FieldInfo.Should().Be(info);
    }


    [TestMethod]
    public void ToName()
    {
        SByteEnum.MinValue.ToName().Should().Be(nameof(SByteEnum.MinValue));
        SByteEnum.Zero.ToName().Should().Be(nameof(SByteEnum.Zero));
        SByteEnum.MaxValue.ToName().Should().Be(nameof(SByteEnum.MaxValue));
    }


    [TestMethod]
    public void ToUnderlying()
    {
        var @enum = SByteEnum.MinValue;
        var value = sbyte.MinValue;

        @enum.ToSByte().Should().Be(value);
        FluentActions.Invoking(() => @enum.ToByte()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToInt16()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToUInt16()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToInt32()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToUInt32()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToInt64()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToUInt64()).Should().Throw<ArgumentException>();
    }


    [TestMethod]
    public void FastToString()
    {
        const SByteEnum undefined = (SByteEnum)123;
        var values = Enum.GetValues<SByteEnum>().Append(undefined);
        foreach (var x in values)
        {
            var expect = x.ToString();
            var actual = x.FastToString();
            actual.Should().Be(expect);
        }
    }
}



/// <summary>
/// Provides unit tests for enum based on <see cref="byte"/> type.
/// </summary>
[TestClass]
public sealed class ByteTests
{
    [TestMethod]
    public void GetUnderlyingType()
        => FastEnum.GetUnderlyingType<ByteEnum>().Should().Be<byte>();


    [TestMethod]
    public void GetValues()
    {
        var expect = Enum.GetValues<ByteEnum>();
        var actual = FastEnum.GetValues<ByteEnum>();
        actual.Should().BeEquivalentTo(expect);
    }


    [TestMethod]
    public void GetNames()
    {
        var expect = Enum.GetNames<ByteEnum>();
        var actual = FastEnum.GetNames<ByteEnum>();
        actual.Should().BeEquivalentTo(expect);
    }


    [TestMethod]
    public void GetName()
    {
        //--- defined value
        {
            const ByteEnum defined = ByteEnum.MinValue;
            var expect = Enum.GetName(defined);
            var actual = FastEnum.GetName(defined);
            actual.Should().NotBeNull();
            actual.Should().BeEquivalentTo(expect);
        }
        //--- undefined value
        {
            const ByteEnum undefined = (ByteEnum)123;
            var expect = Enum.GetName(undefined);
            var actual = FastEnum.GetName(undefined);
            actual.Should().BeNull();
            actual.Should().BeEquivalentTo(expect);
        }
    }


    [TestMethod]
    public void GetMembers()
    {
        var expect
            = Enum.GetNames<ByteEnum>()
            .Select(static name =>
            {
                var value = Enum.Parse<ByteEnum>(name);
                var nameUtf8 = Encoding.UTF8.GetBytes(name);
                var fieldInfo = typeof(ByteEnum).GetField(name);
                return (value, name, nameUtf8, fieldInfo);
            })
            .ToArray();
        var actual = FastEnum.GetMembers<ByteEnum>();

        actual.Length.Should().Be(expect.Length);
        for (var i = 0; i < expect.Length; i++)
        {
            var a = actual[i];
            var e = expect[i];
            a.Value.Should().Be(e.value);
            a.Name.Should().Be(e.name);
            a.NameUtf8.Should().Equal(e.nameUtf8);
            a.FieldInfo.Should().Be(e.fieldInfo);

            var (name, value) = a;
            value.Should().Be(e.value);
            name.Should().Be(e.name);
        }
    }


    [TestMethod]
    public void GetMember()
    {
        //--- defined value
        {
            const ByteEnum defined = ByteEnum.MinValue;
            var expect = getMember(defined);
            var actual = FastEnum.GetMember(defined)!;

            actual.Should().NotBeNull();
            actual.Value.Should().Be(expect.value);
            actual.Name.Should().Be(expect.name);
            actual.NameUtf8.Should().Equal(expect.nameUtf8);
            actual.FieldInfo.Should().Be(expect.fieldInfo);

            var (name, value) = actual;
            value.Should().Be(expect.value);
            name.Should().Be(expect.name);
        }
        //--- undefined value
        {
            const ByteEnum undefined = (ByteEnum)123;
            var actual = FastEnum.GetMember(undefined);
            actual.Should().BeNull();
        }

        #region Local Functions
        static (T value, string name, byte[] nameUtf8, FieldInfo fieldInfo) getMember<T>(T value)
            where T : struct, Enum
        {
            var name = Enum.GetName<T>(value)!;
            var nameUtf8 = Encoding.UTF8.GetBytes(name);
            var fieldInfo = typeof(T).GetField(name)!;
            return (value, name, nameUtf8, fieldInfo);
        }
        #endregion
    }


    [TestMethod]
    public void GetMinValue()
    {
        var min = FastEnum.GetMinValue<ByteEnum>();
        min.Should().NotBeNull();
        min.Should().Be(ByteEnum.MinValue);
    }


    [TestMethod]
    public void GetMaxValue()
    {
        var max = FastEnum.GetMaxValue<ByteEnum>();
        max.Should().NotBeNull();
        max.Should().Be(ByteEnum.MaxValue);
    }


    [TestMethod]
    public void IsEmpty()
        => FastEnum.IsEmpty<ByteEnum>().Should().Be(false);


    [TestMethod]
    public void IsContinuous()
        => FastEnum.IsContinuous<ByteEnum>().Should().Be(false);


    [TestMethod]
    public void IsFlags()
        => FastEnum.IsFlags<ByteEnum>().Should().Be(false);


    [TestMethod]
    public void IsDefined()
    {
        //--- IsDefined(TEnum)
        FastEnum.IsDefined<ByteEnum>(ByteEnum.MinValue).Should().BeTrue();
        FastEnum.IsDefined<ByteEnum>(ByteEnum.MaxValue).Should().BeTrue();
        FastEnum.IsDefined<ByteEnum>((ByteEnum)123).Should().BeFalse();

        //--- Extension methods
        ByteEnum.MinValue.IsDefined().Should().BeTrue();
        ByteEnum.MaxValue.IsDefined().Should().BeTrue();

        //--- IsDefined(ReadOnlySpan<char>)
        FastEnum.IsDefined<ByteEnum>(nameof(ByteEnum.MinValue)).Should().BeTrue();
        FastEnum.IsDefined<ByteEnum>(nameof(ByteEnum.MaxValue)).Should().BeTrue();
        FastEnum.IsDefined<ByteEnum>("123").Should().BeFalse();
        FastEnum.IsDefined<ByteEnum>("minvalue").Should().BeFalse();
    }


    [TestMethod]
    public void Parse()
    {
        var parameters = new[]
        {
            (value: ByteEnum.MinValue, name: nameof(ByteEnum.MinValue), valueString: ((byte)ByteEnum.MinValue).ToString(CultureInfo.InvariantCulture)),
            (value: ByteEnum.MaxValue, name: nameof(ByteEnum.MaxValue), valueString: ((byte)ByteEnum.MaxValue).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.Parse<ByteEnum>(x.name).Should().Be(x.value);
            FluentActions.Invoking(() => FastEnum.Parse<ByteEnum>(x.name.ToLower(CultureInfo.InvariantCulture))).Should().Throw<ArgumentException>();
            FluentActions.Invoking(() => FastEnum.Parse<ByteEnum>(x.name.ToUpper(CultureInfo.InvariantCulture))).Should().Throw<ArgumentException>();
            FastEnum.Parse<ByteEnum>(x.valueString).Should().Be(x.value);
            FastEnum.Parse<ByteEnum>(x.valueString.ToLower(CultureInfo.InvariantCulture)).Should().Be(x.value);
            FastEnum.Parse<ByteEnum>(x.valueString.ToUpper(CultureInfo.InvariantCulture)).Should().Be(x.value);
        }
        FluentActions.Invoking(static () => FastEnum.Parse<ByteEnum>((string?)null, true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<ByteEnum>("")).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<ByteEnum>(" ")).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<ByteEnum>("ABCDE")).Should().Throw<ArgumentException>();
        FastEnum.Parse<ByteEnum>("123").Should().Be((ByteEnum)123);
    }


    [TestMethod]
    public void ParseIgnoreCase()
    {
        var parameters = new[]
        {
            (value: ByteEnum.MinValue, name: nameof(ByteEnum.MinValue), valueString: ((byte)ByteEnum.MinValue).ToString(CultureInfo.InvariantCulture)),
            (value: ByteEnum.MaxValue, name: nameof(ByteEnum.MaxValue), valueString: ((byte)ByteEnum.MaxValue).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.Parse<ByteEnum>(x.name, true).Should().Be(x.value);
            FastEnum.Parse<ByteEnum>(x.name.ToLower(CultureInfo.InvariantCulture), true).Should().Be(x.value);
            FastEnum.Parse<ByteEnum>(x.name.ToUpper(CultureInfo.InvariantCulture), true).Should().Be(x.value);
            FastEnum.Parse<ByteEnum>(x.valueString).Should().Be(x.value);
            FastEnum.Parse<ByteEnum>(x.valueString.ToLower(CultureInfo.InvariantCulture), true).Should().Be(x.value);
            FastEnum.Parse<ByteEnum>(x.valueString.ToUpper(CultureInfo.InvariantCulture), true).Should().Be(x.value);
        }
        FluentActions.Invoking(static () => FastEnum.Parse<ByteEnum>((string?)null, true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<ByteEnum>("", true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<ByteEnum>(" ", true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<ByteEnum>("ABCDE", true)).Should().Throw<ArgumentException>();
        FastEnum.Parse<ByteEnum>("123").Should().Be((ByteEnum)123);
    }


    [TestMethod]
    public void TryParse()
    {
        var parameters = new[]
        {
            (value: ByteEnum.MinValue, name: nameof(ByteEnum.MinValue), valueString: ((byte)ByteEnum.MinValue).ToString(CultureInfo.InvariantCulture)),
            (value: ByteEnum.MaxValue, name: nameof(ByteEnum.MaxValue), valueString: ((byte)ByteEnum.MaxValue).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.TryParse<ByteEnum>(x.name, out var r1).Should().BeTrue();
            r1.Should().Be(x.value);

            FastEnum.TryParse<ByteEnum>(x.name.ToLower(CultureInfo.InvariantCulture), out var _).Should().BeFalse();
            FastEnum.TryParse<ByteEnum>(x.name.ToUpper(CultureInfo.InvariantCulture), out var _).Should().BeFalse();

            FastEnum.TryParse<ByteEnum>(x.valueString, out var r2).Should().BeTrue();
            r2.Should().Be(x.value);

            FastEnum.TryParse<ByteEnum>(x.valueString.ToLower(CultureInfo.InvariantCulture), out var r3).Should().BeTrue();
            r3.Should().Be(x.value);

            FastEnum.TryParse<ByteEnum>(x.valueString.ToUpper(CultureInfo.InvariantCulture), out var r4).Should().BeTrue();
            r4.Should().Be(x.value);
        }
        FastEnum.TryParse<ByteEnum>((string?)null, out var _).Should().BeFalse();
        FastEnum.TryParse<ByteEnum>("", out var _).Should().BeFalse();
        FastEnum.TryParse<ByteEnum>(" ", out var _).Should().BeFalse();
        FastEnum.TryParse<ByteEnum>("ABCDE", out var _).Should().BeFalse();
        FastEnum.TryParse<ByteEnum>("123", out var r).Should().BeTrue();
        r.Should().Be((ByteEnum)123);
    }


    [TestMethod]
    public void TryParseIgnoreCase()
    {
        var parameters = new[]
        {
            (value: ByteEnum.MinValue, name: nameof(ByteEnum.MinValue), valueString: ((byte)ByteEnum.MinValue).ToString(CultureInfo.InvariantCulture)),
            (value: ByteEnum.MaxValue, name: nameof(ByteEnum.MaxValue), valueString: ((byte)ByteEnum.MaxValue).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.TryParse<ByteEnum>(x.name, true, out var r1).Should().BeTrue();
            r1.Should().Be(x.value);

            FastEnum.TryParse<ByteEnum>(x.name.ToLower(CultureInfo.InvariantCulture), true, out var r2).Should().BeTrue();
            r2.Should().Be(x.value);

            FastEnum.TryParse<ByteEnum>(x.name.ToUpper(CultureInfo.InvariantCulture), true, out var r3).Should().BeTrue();
            r3.Should().Be(x.value);

            FastEnum.TryParse<ByteEnum>(x.valueString, true, out var r4).Should().BeTrue();
            r4.Should().Be(x.value);

            FastEnum.TryParse<ByteEnum>(x.valueString.ToLower(CultureInfo.InvariantCulture), true, out var r5).Should().BeTrue();
            r5.Should().Be(x.value);

            FastEnum.TryParse<ByteEnum>(x.valueString.ToUpper(CultureInfo.InvariantCulture), true, out var r6).Should().BeTrue();
            r6.Should().Be(x.value);
        }
        FastEnum.TryParse<ByteEnum>((string?)null, true, out var _).Should().BeFalse();
        FastEnum.TryParse<ByteEnum>("", true, out var _).Should().BeFalse();
        FastEnum.TryParse<ByteEnum>(" ", true, out var _).Should().BeFalse();
        FastEnum.TryParse<ByteEnum>("ABCDE", true, out var _).Should().BeFalse();
        FastEnum.TryParse<ByteEnum>("123", true, out var r).Should().BeTrue();
        r.Should().Be((ByteEnum)123);
    }


    [TestMethod]
    public void ToMember()
    {
        var value = ByteEnum.MaxValue;
        var name = nameof(ByteEnum.MaxValue);
        var nameUtf8 = Encoding.UTF8.GetBytes(name);
        var member = value.ToMember()!;
        var info = typeof(ByteEnum).GetField(name);

        member.Should().NotBeNull();
        member.Name.Should().Be(name);
        member.NameUtf8.Should().Equal(nameUtf8);
        member.Value.Should().Be(value);
        member.FieldInfo.Should().Be(info);
    }


    [TestMethod]
    public void ToName()
    {
        ByteEnum.MinValue.ToName().Should().Be(nameof(ByteEnum.MinValue));
        ByteEnum.MaxValue.ToName().Should().Be(nameof(ByteEnum.MaxValue));
    }


    [TestMethod]
    public void ToUnderlying()
    {
        var @enum = ByteEnum.MinValue;
        var value = byte.MinValue;

        FluentActions.Invoking(() => @enum.ToSByte()).Should().Throw<ArgumentException>();
        @enum.ToByte().Should().Be(value);
        FluentActions.Invoking(() => @enum.ToInt16()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToUInt16()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToInt32()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToUInt32()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToInt64()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToUInt64()).Should().Throw<ArgumentException>();
    }


    [TestMethod]
    public void FastToString()
    {
        const ByteEnum undefined = (ByteEnum)123;
        var values = Enum.GetValues<ByteEnum>().Append(undefined);
        foreach (var x in values)
        {
            var expect = x.ToString();
            var actual = x.FastToString();
            actual.Should().Be(expect);
        }
    }
}



/// <summary>
/// Provides unit tests for enum based on <see cref="short"/> type.
/// </summary>
[TestClass]
public sealed class Int16Tests
{
    [TestMethod]
    public void GetUnderlyingType()
        => FastEnum.GetUnderlyingType<Int16Enum>().Should().Be<short>();


    [TestMethod]
    public void GetValues()
    {
        var expect = Enum.GetValues<Int16Enum>();
        var actual = FastEnum.GetValues<Int16Enum>();
        actual.Should().BeEquivalentTo(expect);
    }


    [TestMethod]
    public void GetNames()
    {
        var expect = Enum.GetNames<Int16Enum>();
        var actual = FastEnum.GetNames<Int16Enum>();
        actual.Should().BeEquivalentTo(expect);
    }


    [TestMethod]
    public void GetName()
    {
        //--- defined value
        {
            const Int16Enum defined = Int16Enum.MinValue;
            var expect = Enum.GetName(defined);
            var actual = FastEnum.GetName(defined);
            actual.Should().NotBeNull();
            actual.Should().BeEquivalentTo(expect);
        }
        //--- undefined value
        {
            const Int16Enum undefined = (Int16Enum)123;
            var expect = Enum.GetName(undefined);
            var actual = FastEnum.GetName(undefined);
            actual.Should().BeNull();
            actual.Should().BeEquivalentTo(expect);
        }
    }


    [TestMethod]
    public void GetMembers()
    {
        var expect
            = Enum.GetNames<Int16Enum>()
            .Select(static name =>
            {
                var value = Enum.Parse<Int16Enum>(name);
                var nameUtf8 = Encoding.UTF8.GetBytes(name);
                var fieldInfo = typeof(Int16Enum).GetField(name);
                return (value, name, nameUtf8, fieldInfo);
            })
            .ToArray();
        var actual = FastEnum.GetMembers<Int16Enum>();

        actual.Length.Should().Be(expect.Length);
        for (var i = 0; i < expect.Length; i++)
        {
            var a = actual[i];
            var e = expect[i];
            a.Value.Should().Be(e.value);
            a.Name.Should().Be(e.name);
            a.NameUtf8.Should().Equal(e.nameUtf8);
            a.FieldInfo.Should().Be(e.fieldInfo);

            var (name, value) = a;
            value.Should().Be(e.value);
            name.Should().Be(e.name);
        }
    }


    [TestMethod]
    public void GetMember()
    {
        //--- defined value
        {
            const Int16Enum defined = Int16Enum.MinValue;
            var expect = getMember(defined);
            var actual = FastEnum.GetMember(defined)!;

            actual.Should().NotBeNull();
            actual.Value.Should().Be(expect.value);
            actual.Name.Should().Be(expect.name);
            actual.NameUtf8.Should().Equal(expect.nameUtf8);
            actual.FieldInfo.Should().Be(expect.fieldInfo);

            var (name, value) = actual;
            value.Should().Be(expect.value);
            name.Should().Be(expect.name);
        }
        //--- undefined value
        {
            const Int16Enum undefined = (Int16Enum)123;
            var actual = FastEnum.GetMember(undefined);
            actual.Should().BeNull();
        }

        #region Local Functions
        static (T value, string name, byte[] nameUtf8, FieldInfo fieldInfo) getMember<T>(T value)
            where T : struct, Enum
        {
            var name = Enum.GetName<T>(value)!;
            var nameUtf8 = Encoding.UTF8.GetBytes(name);
            var fieldInfo = typeof(T).GetField(name)!;
            return (value, name, nameUtf8, fieldInfo);
        }
        #endregion
    }


    [TestMethod]
    public void GetMinValue()
    {
        var min = FastEnum.GetMinValue<Int16Enum>();
        min.Should().NotBeNull();
        min.Should().Be(Int16Enum.MinValue);
    }


    [TestMethod]
    public void GetMaxValue()
    {
        var max = FastEnum.GetMaxValue<Int16Enum>();
        max.Should().NotBeNull();
        max.Should().Be(Int16Enum.MaxValue);
    }


    [TestMethod]
    public void IsEmpty()
        => FastEnum.IsEmpty<Int16Enum>().Should().Be(false);


    [TestMethod]
    public void IsContinuous()
        => FastEnum.IsContinuous<Int16Enum>().Should().Be(false);


    [TestMethod]
    public void IsFlags()
        => FastEnum.IsFlags<Int16Enum>().Should().Be(false);


    [TestMethod]
    public void IsDefined()
    {
        //--- IsDefined(TEnum)
        FastEnum.IsDefined<Int16Enum>(Int16Enum.MinValue).Should().BeTrue();
        FastEnum.IsDefined<Int16Enum>(Int16Enum.Zero).Should().BeTrue();
        FastEnum.IsDefined<Int16Enum>(Int16Enum.MaxValue).Should().BeTrue();
        FastEnum.IsDefined<Int16Enum>((Int16Enum)123).Should().BeFalse();

        //--- Extension methods
        Int16Enum.MinValue.IsDefined().Should().BeTrue();
        Int16Enum.Zero.IsDefined().Should().BeTrue();
        Int16Enum.MaxValue.IsDefined().Should().BeTrue();

        //--- IsDefined(ReadOnlySpan<char>)
        FastEnum.IsDefined<Int16Enum>(nameof(Int16Enum.MinValue)).Should().BeTrue();
        FastEnum.IsDefined<Int16Enum>(nameof(Int16Enum.Zero)).Should().BeTrue();
        FastEnum.IsDefined<Int16Enum>(nameof(Int16Enum.MaxValue)).Should().BeTrue();
        FastEnum.IsDefined<Int16Enum>("123").Should().BeFalse();
        FastEnum.IsDefined<Int16Enum>("minvalue").Should().BeFalse();
    }


    [TestMethod]
    public void Parse()
    {
        var parameters = new[]
        {
            (value: Int16Enum.MinValue, name: nameof(Int16Enum.MinValue), valueString: ((short)Int16Enum.MinValue).ToString(CultureInfo.InvariantCulture)),
            (value: Int16Enum.Zero,     name: nameof(Int16Enum.Zero),     valueString: ((short)Int16Enum.Zero).ToString(CultureInfo.InvariantCulture)),
            (value: Int16Enum.MaxValue, name: nameof(Int16Enum.MaxValue), valueString: ((short)Int16Enum.MaxValue).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.Parse<Int16Enum>(x.name).Should().Be(x.value);
            FluentActions.Invoking(() => FastEnum.Parse<Int16Enum>(x.name.ToLower(CultureInfo.InvariantCulture))).Should().Throw<ArgumentException>();
            FluentActions.Invoking(() => FastEnum.Parse<Int16Enum>(x.name.ToUpper(CultureInfo.InvariantCulture))).Should().Throw<ArgumentException>();
            FastEnum.Parse<Int16Enum>(x.valueString).Should().Be(x.value);
            FastEnum.Parse<Int16Enum>(x.valueString.ToLower(CultureInfo.InvariantCulture)).Should().Be(x.value);
            FastEnum.Parse<Int16Enum>(x.valueString.ToUpper(CultureInfo.InvariantCulture)).Should().Be(x.value);
        }
        FluentActions.Invoking(static () => FastEnum.Parse<Int16Enum>((string?)null, true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<Int16Enum>("")).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<Int16Enum>(" ")).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<Int16Enum>("ABCDE")).Should().Throw<ArgumentException>();
        FastEnum.Parse<Int16Enum>("123").Should().Be((Int16Enum)123);
    }


    [TestMethod]
    public void ParseIgnoreCase()
    {
        var parameters = new[]
        {
            (value: Int16Enum.MinValue, name: nameof(Int16Enum.MinValue), valueString: ((short)Int16Enum.MinValue).ToString(CultureInfo.InvariantCulture)),
            (value: Int16Enum.Zero,     name: nameof(Int16Enum.Zero),     valueString: ((short)Int16Enum.Zero).ToString(CultureInfo.InvariantCulture)),
            (value: Int16Enum.MaxValue, name: nameof(Int16Enum.MaxValue), valueString: ((short)Int16Enum.MaxValue).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.Parse<Int16Enum>(x.name, true).Should().Be(x.value);
            FastEnum.Parse<Int16Enum>(x.name.ToLower(CultureInfo.InvariantCulture), true).Should().Be(x.value);
            FastEnum.Parse<Int16Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), true).Should().Be(x.value);
            FastEnum.Parse<Int16Enum>(x.valueString).Should().Be(x.value);
            FastEnum.Parse<Int16Enum>(x.valueString.ToLower(CultureInfo.InvariantCulture), true).Should().Be(x.value);
            FastEnum.Parse<Int16Enum>(x.valueString.ToUpper(CultureInfo.InvariantCulture), true).Should().Be(x.value);
        }
        FluentActions.Invoking(static () => FastEnum.Parse<Int16Enum>((string?)null, true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<Int16Enum>("", true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<Int16Enum>(" ", true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<Int16Enum>("ABCDE", true)).Should().Throw<ArgumentException>();
        FastEnum.Parse<Int16Enum>("123").Should().Be((Int16Enum)123);
    }


    [TestMethod]
    public void TryParse()
    {
        var parameters = new[]
        {
            (value: Int16Enum.MinValue, name: nameof(Int16Enum.MinValue), valueString: ((short)Int16Enum.MinValue).ToString(CultureInfo.InvariantCulture)),
            (value: Int16Enum.Zero,     name: nameof(Int16Enum.Zero),     valueString: ((short)Int16Enum.Zero).ToString(CultureInfo.InvariantCulture)),
            (value: Int16Enum.MaxValue, name: nameof(Int16Enum.MaxValue), valueString: ((short)Int16Enum.MaxValue).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.TryParse<Int16Enum>(x.name, out var r1).Should().BeTrue();
            r1.Should().Be(x.value);

            FastEnum.TryParse<Int16Enum>(x.name.ToLower(CultureInfo.InvariantCulture), out var _).Should().BeFalse();
            FastEnum.TryParse<Int16Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), out var _).Should().BeFalse();

            FastEnum.TryParse<Int16Enum>(x.valueString, out var r2).Should().BeTrue();
            r2.Should().Be(x.value);

            FastEnum.TryParse<Int16Enum>(x.valueString.ToLower(CultureInfo.InvariantCulture), out var r3).Should().BeTrue();
            r3.Should().Be(x.value);

            FastEnum.TryParse<Int16Enum>(x.valueString.ToUpper(CultureInfo.InvariantCulture), out var r4).Should().BeTrue();
            r4.Should().Be(x.value);
        }
        FastEnum.TryParse<Int16Enum>((string?)null, out var _).Should().BeFalse();
        FastEnum.TryParse<Int16Enum>("", out var _).Should().BeFalse();
        FastEnum.TryParse<Int16Enum>(" ", out var _).Should().BeFalse();
        FastEnum.TryParse<Int16Enum>("ABCDE", out var _).Should().BeFalse();
        FastEnum.TryParse<Int16Enum>("123", out var r).Should().BeTrue();
        r.Should().Be((Int16Enum)123);
    }


    [TestMethod]
    public void TryParseIgnoreCase()
    {
        var parameters = new[]
        {
            (value: Int16Enum.MinValue, name: nameof(Int16Enum.MinValue), valueString: ((short)Int16Enum.MinValue).ToString(CultureInfo.InvariantCulture)),
            (value: Int16Enum.Zero,     name: nameof(Int16Enum.Zero),     valueString: ((short)Int16Enum.Zero).ToString(CultureInfo.InvariantCulture)),
            (value: Int16Enum.MaxValue, name: nameof(Int16Enum.MaxValue), valueString: ((short)Int16Enum.MaxValue).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.TryParse<Int16Enum>(x.name, true, out var r1).Should().BeTrue();
            r1.Should().Be(x.value);

            FastEnum.TryParse<Int16Enum>(x.name.ToLower(CultureInfo.InvariantCulture), true, out var r2).Should().BeTrue();
            r2.Should().Be(x.value);

            FastEnum.TryParse<Int16Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), true, out var r3).Should().BeTrue();
            r3.Should().Be(x.value);

            FastEnum.TryParse<Int16Enum>(x.valueString, true, out var r4).Should().BeTrue();
            r4.Should().Be(x.value);

            FastEnum.TryParse<Int16Enum>(x.valueString.ToLower(CultureInfo.InvariantCulture), true, out var r5).Should().BeTrue();
            r5.Should().Be(x.value);

            FastEnum.TryParse<Int16Enum>(x.valueString.ToUpper(CultureInfo.InvariantCulture), true, out var r6).Should().BeTrue();
            r6.Should().Be(x.value);
        }
        FastEnum.TryParse<Int16Enum>((string?)null, true, out var _).Should().BeFalse();
        FastEnum.TryParse<Int16Enum>("", true, out var _).Should().BeFalse();
        FastEnum.TryParse<Int16Enum>(" ", true, out var _).Should().BeFalse();
        FastEnum.TryParse<Int16Enum>("ABCDE", true, out var _).Should().BeFalse();
        FastEnum.TryParse<Int16Enum>("123", true, out var r).Should().BeTrue();
        r.Should().Be((Int16Enum)123);
    }


    [TestMethod]
    public void ToMember()
    {
        var value = Int16Enum.MaxValue;
        var name = nameof(Int16Enum.MaxValue);
        var nameUtf8 = Encoding.UTF8.GetBytes(name);
        var member = value.ToMember()!;
        var info = typeof(Int16Enum).GetField(name);

        member.Should().NotBeNull();
        member.Name.Should().Be(name);
        member.NameUtf8.Should().Equal(nameUtf8);
        member.Value.Should().Be(value);
        member.FieldInfo.Should().Be(info);
    }


    [TestMethod]
    public void ToName()
    {
        Int16Enum.MinValue.ToName().Should().Be(nameof(Int16Enum.MinValue));
        Int16Enum.Zero.ToName().Should().Be(nameof(Int16Enum.Zero));
        Int16Enum.MaxValue.ToName().Should().Be(nameof(Int16Enum.MaxValue));
    }


    [TestMethod]
    public void ToUnderlying()
    {
        var @enum = Int16Enum.MinValue;
        var value = short.MinValue;

        FluentActions.Invoking(() => @enum.ToSByte()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToByte()).Should().Throw<ArgumentException>();
        @enum.ToInt16().Should().Be(value);
        FluentActions.Invoking(() => @enum.ToUInt16()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToInt32()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToUInt32()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToInt64()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToUInt64()).Should().Throw<ArgumentException>();
    }


    [TestMethod]
    public void FastToString()
    {
        const Int16Enum undefined = (Int16Enum)123;
        var values = Enum.GetValues<Int16Enum>().Append(undefined);
        foreach (var x in values)
        {
            var expect = x.ToString();
            var actual = x.FastToString();
            actual.Should().Be(expect);
        }
    }
}



/// <summary>
/// Provides unit tests for enum based on <see cref="ushort"/> type.
/// </summary>
[TestClass]
public sealed class UInt16Tests
{
    [TestMethod]
    public void GetUnderlyingType()
        => FastEnum.GetUnderlyingType<UInt16Enum>().Should().Be<ushort>();


    [TestMethod]
    public void GetValues()
    {
        var expect = Enum.GetValues<UInt16Enum>();
        var actual = FastEnum.GetValues<UInt16Enum>();
        actual.Should().BeEquivalentTo(expect);
    }


    [TestMethod]
    public void GetNames()
    {
        var expect = Enum.GetNames<UInt16Enum>();
        var actual = FastEnum.GetNames<UInt16Enum>();
        actual.Should().BeEquivalentTo(expect);
    }


    [TestMethod]
    public void GetName()
    {
        //--- defined value
        {
            const UInt16Enum defined = UInt16Enum.MinValue;
            var expect = Enum.GetName(defined);
            var actual = FastEnum.GetName(defined);
            actual.Should().NotBeNull();
            actual.Should().BeEquivalentTo(expect);
        }
        //--- undefined value
        {
            const UInt16Enum undefined = (UInt16Enum)123;
            var expect = Enum.GetName(undefined);
            var actual = FastEnum.GetName(undefined);
            actual.Should().BeNull();
            actual.Should().BeEquivalentTo(expect);
        }
    }


    [TestMethod]
    public void GetMembers()
    {
        var expect
            = Enum.GetNames<UInt16Enum>()
            .Select(static name =>
            {
                var value = Enum.Parse<UInt16Enum>(name);
                var nameUtf8 = Encoding.UTF8.GetBytes(name);
                var fieldInfo = typeof(UInt16Enum).GetField(name);
                return (value, name, nameUtf8, fieldInfo);
            })
            .ToArray();
        var actual = FastEnum.GetMembers<UInt16Enum>();

        actual.Length.Should().Be(expect.Length);
        for (var i = 0; i < expect.Length; i++)
        {
            var a = actual[i];
            var e = expect[i];
            a.Value.Should().Be(e.value);
            a.Name.Should().Be(e.name);
            a.NameUtf8.Should().Equal(e.nameUtf8);
            a.FieldInfo.Should().Be(e.fieldInfo);

            var (name, value) = a;
            value.Should().Be(e.value);
            name.Should().Be(e.name);
        }
    }


    [TestMethod]
    public void GetMember()
    {
        //--- defined value
        {
            const UInt16Enum defined = UInt16Enum.MinValue;
            var expect = getMember(defined);
            var actual = FastEnum.GetMember(defined)!;

            actual.Should().NotBeNull();
            actual.Value.Should().Be(expect.value);
            actual.Name.Should().Be(expect.name);
            actual.NameUtf8.Should().Equal(expect.nameUtf8);
            actual.FieldInfo.Should().Be(expect.fieldInfo);

            var (name, value) = actual;
            value.Should().Be(expect.value);
            name.Should().Be(expect.name);
        }
        //--- undefined value
        {
            const UInt16Enum undefined = (UInt16Enum)123;
            var actual = FastEnum.GetMember(undefined);
            actual.Should().BeNull();
        }

        #region Local Functions
        static (T value, string name, byte[] nameUtf8, FieldInfo fieldInfo) getMember<T>(T value)
            where T : struct, Enum
        {
            var name = Enum.GetName<T>(value)!;
            var nameUtf8 = Encoding.UTF8.GetBytes(name);
            var fieldInfo = typeof(T).GetField(name)!;
            return (value, name, nameUtf8, fieldInfo);
        }
        #endregion
    }


    [TestMethod]
    public void GetMinValue()
    {
        var min = FastEnum.GetMinValue<UInt16Enum>();
        min.Should().NotBeNull();
        min.Should().Be(UInt16Enum.MinValue);
    }


    [TestMethod]
    public void GetMaxValue()
    {
        var max = FastEnum.GetMaxValue<UInt16Enum>();
        max.Should().NotBeNull();
        max.Should().Be(UInt16Enum.MaxValue);
    }


    [TestMethod]
    public void IsEmpty()
        => FastEnum.IsEmpty<UInt16Enum>().Should().Be(false);


    [TestMethod]
    public void IsContinuous()
        => FastEnum.IsContinuous<UInt16Enum>().Should().Be(false);


    [TestMethod]
    public void IsFlags()
        => FastEnum.IsFlags<UInt16Enum>().Should().Be(false);


    [TestMethod]
    public void IsDefined()
    {
        //--- IsDefined(TEnum)
        FastEnum.IsDefined<UInt16Enum>(UInt16Enum.MinValue).Should().BeTrue();
        FastEnum.IsDefined<UInt16Enum>(UInt16Enum.MaxValue).Should().BeTrue();
        FastEnum.IsDefined<UInt16Enum>((UInt16Enum)123).Should().BeFalse();

        //--- Extension methods
        UInt16Enum.MinValue.IsDefined().Should().BeTrue();
        UInt16Enum.MaxValue.IsDefined().Should().BeTrue();

        //--- IsDefined(ReadOnlySpan<char>)
        FastEnum.IsDefined<UInt16Enum>(nameof(UInt16Enum.MinValue)).Should().BeTrue();
        FastEnum.IsDefined<UInt16Enum>(nameof(UInt16Enum.MaxValue)).Should().BeTrue();
        FastEnum.IsDefined<UInt16Enum>("123").Should().BeFalse();
        FastEnum.IsDefined<UInt16Enum>("minvalue").Should().BeFalse();
    }


    [TestMethod]
    public void Parse()
    {
        var parameters = new[]
        {
            (value: UInt16Enum.MinValue, name: nameof(UInt16Enum.MinValue), valueString: ((ushort)UInt16Enum.MinValue).ToString(CultureInfo.InvariantCulture)),
            (value: UInt16Enum.MaxValue, name: nameof(UInt16Enum.MaxValue), valueString: ((ushort)UInt16Enum.MaxValue).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.Parse<UInt16Enum>(x.name).Should().Be(x.value);
            FluentActions.Invoking(() => FastEnum.Parse<UInt16Enum>(x.name.ToLower(CultureInfo.InvariantCulture))).Should().Throw<ArgumentException>();
            FluentActions.Invoking(() => FastEnum.Parse<UInt16Enum>(x.name.ToUpper(CultureInfo.InvariantCulture))).Should().Throw<ArgumentException>();
            FastEnum.Parse<UInt16Enum>(x.valueString).Should().Be(x.value);
            FastEnum.Parse<UInt16Enum>(x.valueString.ToLower(CultureInfo.InvariantCulture)).Should().Be(x.value);
            FastEnum.Parse<UInt16Enum>(x.valueString.ToUpper(CultureInfo.InvariantCulture)).Should().Be(x.value);
        }
        FluentActions.Invoking(static () => FastEnum.Parse<UInt16Enum>((string?)null, true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<UInt16Enum>("")).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<UInt16Enum>(" ")).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<UInt16Enum>("ABCDE")).Should().Throw<ArgumentException>();
        FastEnum.Parse<UInt16Enum>("123").Should().Be((UInt16Enum)123);
    }


    [TestMethod]
    public void ParseIgnoreCase()
    {
        var parameters = new[]
        {
            (value: UInt16Enum.MinValue, name: nameof(UInt16Enum.MinValue), valueString: ((ushort)UInt16Enum.MinValue).ToString(CultureInfo.InvariantCulture)),
            (value: UInt16Enum.MaxValue, name: nameof(UInt16Enum.MaxValue), valueString: ((ushort)UInt16Enum.MaxValue).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.Parse<UInt16Enum>(x.name, true).Should().Be(x.value);
            FastEnum.Parse<UInt16Enum>(x.name.ToLower(CultureInfo.InvariantCulture), true).Should().Be(x.value);
            FastEnum.Parse<UInt16Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), true).Should().Be(x.value);
            FastEnum.Parse<UInt16Enum>(x.valueString).Should().Be(x.value);
            FastEnum.Parse<UInt16Enum>(x.valueString.ToLower(CultureInfo.InvariantCulture), true).Should().Be(x.value);
            FastEnum.Parse<UInt16Enum>(x.valueString.ToUpper(CultureInfo.InvariantCulture), true).Should().Be(x.value);
        }
        FluentActions.Invoking(static () => FastEnum.Parse<UInt16Enum>((string?)null, true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<UInt16Enum>("", true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<UInt16Enum>(" ", true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<UInt16Enum>("ABCDE", true)).Should().Throw<ArgumentException>();
        FastEnum.Parse<UInt16Enum>("123").Should().Be((UInt16Enum)123);
    }


    [TestMethod]
    public void TryParse()
    {
        var parameters = new[]
        {
            (value: UInt16Enum.MinValue, name: nameof(UInt16Enum.MinValue), valueString: ((ushort)UInt16Enum.MinValue).ToString(CultureInfo.InvariantCulture)),
            (value: UInt16Enum.MaxValue, name: nameof(UInt16Enum.MaxValue), valueString: ((ushort)UInt16Enum.MaxValue).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.TryParse<UInt16Enum>(x.name, out var r1).Should().BeTrue();
            r1.Should().Be(x.value);

            FastEnum.TryParse<UInt16Enum>(x.name.ToLower(CultureInfo.InvariantCulture), out var _).Should().BeFalse();
            FastEnum.TryParse<UInt16Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), out var _).Should().BeFalse();

            FastEnum.TryParse<UInt16Enum>(x.valueString, out var r2).Should().BeTrue();
            r2.Should().Be(x.value);

            FastEnum.TryParse<UInt16Enum>(x.valueString.ToLower(CultureInfo.InvariantCulture), out var r3).Should().BeTrue();
            r3.Should().Be(x.value);

            FastEnum.TryParse<UInt16Enum>(x.valueString.ToUpper(CultureInfo.InvariantCulture), out var r4).Should().BeTrue();
            r4.Should().Be(x.value);
        }
        FastEnum.TryParse<UInt16Enum>((string?)null, out var _).Should().BeFalse();
        FastEnum.TryParse<UInt16Enum>("", out var _).Should().BeFalse();
        FastEnum.TryParse<UInt16Enum>(" ", out var _).Should().BeFalse();
        FastEnum.TryParse<UInt16Enum>("ABCDE", out var _).Should().BeFalse();
        FastEnum.TryParse<UInt16Enum>("123", out var r).Should().BeTrue();
        r.Should().Be((UInt16Enum)123);
    }


    [TestMethod]
    public void TryParseIgnoreCase()
    {
        var parameters = new[]
        {
            (value: UInt16Enum.MinValue, name: nameof(UInt16Enum.MinValue), valueString: ((ushort)UInt16Enum.MinValue).ToString(CultureInfo.InvariantCulture)),
            (value: UInt16Enum.MaxValue, name: nameof(UInt16Enum.MaxValue), valueString: ((ushort)UInt16Enum.MaxValue).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.TryParse<UInt16Enum>(x.name, true, out var r1).Should().BeTrue();
            r1.Should().Be(x.value);

            FastEnum.TryParse<UInt16Enum>(x.name.ToLower(CultureInfo.InvariantCulture), true, out var r2).Should().BeTrue();
            r2.Should().Be(x.value);

            FastEnum.TryParse<UInt16Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), true, out var r3).Should().BeTrue();
            r3.Should().Be(x.value);

            FastEnum.TryParse<UInt16Enum>(x.valueString, true, out var r4).Should().BeTrue();
            r4.Should().Be(x.value);

            FastEnum.TryParse<UInt16Enum>(x.valueString.ToLower(CultureInfo.InvariantCulture), true, out var r5).Should().BeTrue();
            r5.Should().Be(x.value);

            FastEnum.TryParse<UInt16Enum>(x.valueString.ToUpper(CultureInfo.InvariantCulture), true, out var r6).Should().BeTrue();
            r6.Should().Be(x.value);
        }
        FastEnum.TryParse<UInt16Enum>((string?)null, true, out var _).Should().BeFalse();
        FastEnum.TryParse<UInt16Enum>("", true, out var _).Should().BeFalse();
        FastEnum.TryParse<UInt16Enum>(" ", true, out var _).Should().BeFalse();
        FastEnum.TryParse<UInt16Enum>("ABCDE", true, out var _).Should().BeFalse();
        FastEnum.TryParse<UInt16Enum>("123", true, out var r).Should().BeTrue();
        r.Should().Be((UInt16Enum)123);
    }


    [TestMethod]
    public void ToMember()
    {
        var value = UInt16Enum.MaxValue;
        var name = nameof(UInt16Enum.MaxValue);
        var nameUtf8 = Encoding.UTF8.GetBytes(name);
        var member = value.ToMember()!;
        var info = typeof(UInt16Enum).GetField(name);

        member.Should().NotBeNull();
        member.Name.Should().Be(name);
        member.NameUtf8.Should().Equal(nameUtf8);
        member.Value.Should().Be(value);
        member.FieldInfo.Should().Be(info);
    }


    [TestMethod]
    public void ToName()
    {
        UInt16Enum.MinValue.ToName().Should().Be(nameof(UInt16Enum.MinValue));
        UInt16Enum.MaxValue.ToName().Should().Be(nameof(UInt16Enum.MaxValue));
    }


    [TestMethod]
    public void ToUnderlying()
    {
        var @enum = UInt16Enum.MinValue;
        var value = ushort.MinValue;

        FluentActions.Invoking(() => @enum.ToSByte()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToByte()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToInt16()).Should().Throw<ArgumentException>();
        @enum.ToUInt16().Should().Be(value);
        FluentActions.Invoking(() => @enum.ToInt32()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToUInt32()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToInt64()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToUInt64()).Should().Throw<ArgumentException>();
    }


    [TestMethod]
    public void FastToString()
    {
        const UInt16Enum undefined = (UInt16Enum)123;
        var values = Enum.GetValues<UInt16Enum>().Append(undefined);
        foreach (var x in values)
        {
            var expect = x.ToString();
            var actual = x.FastToString();
            actual.Should().Be(expect);
        }
    }
}



/// <summary>
/// Provides unit tests for enum based on <see cref="int"/> type.
/// </summary>
[TestClass]
public sealed class Int32Tests
{
    [TestMethod]
    public void GetUnderlyingType()
        => FastEnum.GetUnderlyingType<Int32Enum>().Should().Be<int>();


    [TestMethod]
    public void GetValues()
    {
        var expect = Enum.GetValues<Int32Enum>();
        var actual = FastEnum.GetValues<Int32Enum>();
        actual.Should().BeEquivalentTo(expect);
    }


    [TestMethod]
    public void GetNames()
    {
        var expect = Enum.GetNames<Int32Enum>();
        var actual = FastEnum.GetNames<Int32Enum>();
        actual.Should().BeEquivalentTo(expect);
    }


    [TestMethod]
    public void GetName()
    {
        //--- defined value
        {
            const Int32Enum defined = Int32Enum.MinValue;
            var expect = Enum.GetName(defined);
            var actual = FastEnum.GetName(defined);
            actual.Should().NotBeNull();
            actual.Should().BeEquivalentTo(expect);
        }
        //--- undefined value
        {
            const Int32Enum undefined = (Int32Enum)123;
            var expect = Enum.GetName(undefined);
            var actual = FastEnum.GetName(undefined);
            actual.Should().BeNull();
            actual.Should().BeEquivalentTo(expect);
        }
    }


    [TestMethod]
    public void GetMembers()
    {
        var expect
            = Enum.GetNames<Int32Enum>()
            .Select(static name =>
            {
                var value = Enum.Parse<Int32Enum>(name);
                var nameUtf8 = Encoding.UTF8.GetBytes(name);
                var fieldInfo = typeof(Int32Enum).GetField(name);
                return (value, name, nameUtf8, fieldInfo);
            })
            .ToArray();
        var actual = FastEnum.GetMembers<Int32Enum>();

        actual.Length.Should().Be(expect.Length);
        for (var i = 0; i < expect.Length; i++)
        {
            var a = actual[i];
            var e = expect[i];
            a.Value.Should().Be(e.value);
            a.Name.Should().Be(e.name);
            a.NameUtf8.Should().Equal(e.nameUtf8);
            a.FieldInfo.Should().Be(e.fieldInfo);

            var (name, value) = a;
            value.Should().Be(e.value);
            name.Should().Be(e.name);
        }
    }


    [TestMethod]
    public void GetMember()
    {
        //--- defined value
        {
            const Int32Enum defined = Int32Enum.MinValue;
            var expect = getMember(defined);
            var actual = FastEnum.GetMember(defined)!;

            actual.Should().NotBeNull();
            actual.Value.Should().Be(expect.value);
            actual.Name.Should().Be(expect.name);
            actual.NameUtf8.Should().Equal(expect.nameUtf8);
            actual.FieldInfo.Should().Be(expect.fieldInfo);

            var (name, value) = actual;
            value.Should().Be(expect.value);
            name.Should().Be(expect.name);
        }
        //--- undefined value
        {
            const Int32Enum undefined = (Int32Enum)123;
            var actual = FastEnum.GetMember(undefined);
            actual.Should().BeNull();
        }

        #region Local Functions
        static (T value, string name, byte[] nameUtf8, FieldInfo fieldInfo) getMember<T>(T value)
            where T : struct, Enum
        {
            var name = Enum.GetName<T>(value)!;
            var nameUtf8 = Encoding.UTF8.GetBytes(name);
            var fieldInfo = typeof(T).GetField(name)!;
            return (value, name, nameUtf8, fieldInfo);
        }
        #endregion
    }


    [TestMethod]
    public void GetMinValue()
    {
        var min = FastEnum.GetMinValue<Int32Enum>();
        min.Should().NotBeNull();
        min.Should().Be(Int32Enum.MinValue);
    }


    [TestMethod]
    public void GetMaxValue()
    {
        var max = FastEnum.GetMaxValue<Int32Enum>();
        max.Should().NotBeNull();
        max.Should().Be(Int32Enum.MaxValue);
    }


    [TestMethod]
    public void IsEmpty()
        => FastEnum.IsEmpty<Int32Enum>().Should().Be(false);


    [TestMethod]
    public void IsContinuous()
        => FastEnum.IsContinuous<Int32Enum>().Should().Be(false);


    [TestMethod]
    public void IsFlags()
        => FastEnum.IsFlags<Int32Enum>().Should().Be(false);


    [TestMethod]
    public void IsDefined()
    {
        //--- IsDefined(TEnum)
        FastEnum.IsDefined<Int32Enum>(Int32Enum.MinValue).Should().BeTrue();
        FastEnum.IsDefined<Int32Enum>(Int32Enum.Zero).Should().BeTrue();
        FastEnum.IsDefined<Int32Enum>(Int32Enum.MaxValue).Should().BeTrue();
        FastEnum.IsDefined<Int32Enum>((Int32Enum)123).Should().BeFalse();

        //--- Extension methods
        Int32Enum.MinValue.IsDefined().Should().BeTrue();
        Int32Enum.Zero.IsDefined().Should().BeTrue();
        Int32Enum.MaxValue.IsDefined().Should().BeTrue();

        //--- IsDefined(ReadOnlySpan<char>)
        FastEnum.IsDefined<Int32Enum>(nameof(Int32Enum.MinValue)).Should().BeTrue();
        FastEnum.IsDefined<Int32Enum>(nameof(Int32Enum.Zero)).Should().BeTrue();
        FastEnum.IsDefined<Int32Enum>(nameof(Int32Enum.MaxValue)).Should().BeTrue();
        FastEnum.IsDefined<Int32Enum>("123").Should().BeFalse();
        FastEnum.IsDefined<Int32Enum>("minvalue").Should().BeFalse();
    }


    [TestMethod]
    public void Parse()
    {
        var parameters = new[]
        {
            (value: Int32Enum.MinValue, name: nameof(Int32Enum.MinValue), valueString: ((int)Int32Enum.MinValue).ToString(CultureInfo.InvariantCulture)),
            (value: Int32Enum.Zero,     name: nameof(Int32Enum.Zero),     valueString: ((int)Int32Enum.Zero).ToString(CultureInfo.InvariantCulture)),
            (value: Int32Enum.MaxValue, name: nameof(Int32Enum.MaxValue), valueString: ((int)Int32Enum.MaxValue).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.Parse<Int32Enum>(x.name).Should().Be(x.value);
            FluentActions.Invoking(() => FastEnum.Parse<Int32Enum>(x.name.ToLower(CultureInfo.InvariantCulture))).Should().Throw<ArgumentException>();
            FluentActions.Invoking(() => FastEnum.Parse<Int32Enum>(x.name.ToUpper(CultureInfo.InvariantCulture))).Should().Throw<ArgumentException>();
            FastEnum.Parse<Int32Enum>(x.valueString).Should().Be(x.value);
            FastEnum.Parse<Int32Enum>(x.valueString.ToLower(CultureInfo.InvariantCulture)).Should().Be(x.value);
            FastEnum.Parse<Int32Enum>(x.valueString.ToUpper(CultureInfo.InvariantCulture)).Should().Be(x.value);
        }
        FluentActions.Invoking(static () => FastEnum.Parse<Int32Enum>((string?)null, true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<Int32Enum>("")).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<Int32Enum>(" ")).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<Int32Enum>("ABCDE")).Should().Throw<ArgumentException>();
        FastEnum.Parse<Int32Enum>("123").Should().Be((Int32Enum)123);
    }


    [TestMethod]
    public void ParseIgnoreCase()
    {
        var parameters = new[]
        {
            (value: Int32Enum.MinValue, name: nameof(Int32Enum.MinValue), valueString: ((int)Int32Enum.MinValue).ToString(CultureInfo.InvariantCulture)),
            (value: Int32Enum.Zero,     name: nameof(Int32Enum.Zero),     valueString: ((int)Int32Enum.Zero).ToString(CultureInfo.InvariantCulture)),
            (value: Int32Enum.MaxValue, name: nameof(Int32Enum.MaxValue), valueString: ((int)Int32Enum.MaxValue).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.Parse<Int32Enum>(x.name, true).Should().Be(x.value);
            FastEnum.Parse<Int32Enum>(x.name.ToLower(CultureInfo.InvariantCulture), true).Should().Be(x.value);
            FastEnum.Parse<Int32Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), true).Should().Be(x.value);
            FastEnum.Parse<Int32Enum>(x.valueString).Should().Be(x.value);
            FastEnum.Parse<Int32Enum>(x.valueString.ToLower(CultureInfo.InvariantCulture), true).Should().Be(x.value);
            FastEnum.Parse<Int32Enum>(x.valueString.ToUpper(CultureInfo.InvariantCulture), true).Should().Be(x.value);
        }
        FluentActions.Invoking(static () => FastEnum.Parse<Int32Enum>((string?)null, true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<Int32Enum>("", true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<Int32Enum>(" ", true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<Int32Enum>("ABCDE", true)).Should().Throw<ArgumentException>();
        FastEnum.Parse<Int32Enum>("123").Should().Be((Int32Enum)123);
    }


    [TestMethod]
    public void TryParse()
    {
        var parameters = new[]
        {
            (value: Int32Enum.MinValue, name: nameof(Int32Enum.MinValue), valueString: ((int)Int32Enum.MinValue).ToString(CultureInfo.InvariantCulture)),
            (value: Int32Enum.Zero,     name: nameof(Int32Enum.Zero),     valueString: ((int)Int32Enum.Zero).ToString(CultureInfo.InvariantCulture)),
            (value: Int32Enum.MaxValue, name: nameof(Int32Enum.MaxValue), valueString: ((int)Int32Enum.MaxValue).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.TryParse<Int32Enum>(x.name, out var r1).Should().BeTrue();
            r1.Should().Be(x.value);

            FastEnum.TryParse<Int32Enum>(x.name.ToLower(CultureInfo.InvariantCulture), out var _).Should().BeFalse();
            FastEnum.TryParse<Int32Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), out var _).Should().BeFalse();

            FastEnum.TryParse<Int32Enum>(x.valueString, out var r2).Should().BeTrue();
            r2.Should().Be(x.value);

            FastEnum.TryParse<Int32Enum>(x.valueString.ToLower(CultureInfo.InvariantCulture), out var r3).Should().BeTrue();
            r3.Should().Be(x.value);

            FastEnum.TryParse<Int32Enum>(x.valueString.ToUpper(CultureInfo.InvariantCulture), out var r4).Should().BeTrue();
            r4.Should().Be(x.value);
        }
        FastEnum.TryParse<Int32Enum>((string?)null, out var _).Should().BeFalse();
        FastEnum.TryParse<Int32Enum>("", out var _).Should().BeFalse();
        FastEnum.TryParse<Int32Enum>(" ", out var _).Should().BeFalse();
        FastEnum.TryParse<Int32Enum>("ABCDE", out var _).Should().BeFalse();
        FastEnum.TryParse<Int32Enum>("123", out var r).Should().BeTrue();
        r.Should().Be((Int32Enum)123);
    }


    [TestMethod]
    public void TryParseIgnoreCase()
    {
        var parameters = new[]
        {
            (value: Int32Enum.MinValue, name: nameof(Int32Enum.MinValue), valueString: ((int)Int32Enum.MinValue).ToString(CultureInfo.InvariantCulture)),
            (value: Int32Enum.Zero,     name: nameof(Int32Enum.Zero),     valueString: ((int)Int32Enum.Zero).ToString(CultureInfo.InvariantCulture)),
            (value: Int32Enum.MaxValue, name: nameof(Int32Enum.MaxValue), valueString: ((int)Int32Enum.MaxValue).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.TryParse<Int32Enum>(x.name, true, out var r1).Should().BeTrue();
            r1.Should().Be(x.value);

            FastEnum.TryParse<Int32Enum>(x.name.ToLower(CultureInfo.InvariantCulture), true, out var r2).Should().BeTrue();
            r2.Should().Be(x.value);

            FastEnum.TryParse<Int32Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), true, out var r3).Should().BeTrue();
            r3.Should().Be(x.value);

            FastEnum.TryParse<Int32Enum>(x.valueString, true, out var r4).Should().BeTrue();
            r4.Should().Be(x.value);

            FastEnum.TryParse<Int32Enum>(x.valueString.ToLower(CultureInfo.InvariantCulture), true, out var r5).Should().BeTrue();
            r5.Should().Be(x.value);

            FastEnum.TryParse<Int32Enum>(x.valueString.ToUpper(CultureInfo.InvariantCulture), true, out var r6).Should().BeTrue();
            r6.Should().Be(x.value);
        }
        FastEnum.TryParse<Int32Enum>((string?)null, true, out var _).Should().BeFalse();
        FastEnum.TryParse<Int32Enum>("", true, out var _).Should().BeFalse();
        FastEnum.TryParse<Int32Enum>(" ", true, out var _).Should().BeFalse();
        FastEnum.TryParse<Int32Enum>("ABCDE", true, out var _).Should().BeFalse();
        FastEnum.TryParse<Int32Enum>("123", true, out var r).Should().BeTrue();
        r.Should().Be((Int32Enum)123);
    }


    [TestMethod]
    public void ToMember()
    {
        var value = Int32Enum.MaxValue;
        var name = nameof(Int32Enum.MaxValue);
        var nameUtf8 = Encoding.UTF8.GetBytes(name);
        var member = value.ToMember()!;
        var info = typeof(Int32Enum).GetField(name);

        member.Should().NotBeNull();
        member.Name.Should().Be(name);
        member.NameUtf8.Should().Equal(nameUtf8);
        member.Value.Should().Be(value);
        member.FieldInfo.Should().Be(info);
    }


    [TestMethod]
    public void ToName()
    {
        Int32Enum.MinValue.ToName().Should().Be(nameof(Int32Enum.MinValue));
        Int32Enum.Zero.ToName().Should().Be(nameof(Int32Enum.Zero));
        Int32Enum.MaxValue.ToName().Should().Be(nameof(Int32Enum.MaxValue));
    }


    [TestMethod]
    public void ToUnderlying()
    {
        var @enum = Int32Enum.MinValue;
        var value = int.MinValue;

        FluentActions.Invoking(() => @enum.ToSByte()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToByte()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToInt16()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToUInt16()).Should().Throw<ArgumentException>();
        @enum.ToInt32().Should().Be(value);
        FluentActions.Invoking(() => @enum.ToUInt32()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToInt64()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToUInt64()).Should().Throw<ArgumentException>();
    }


    [TestMethod]
    public void FastToString()
    {
        const Int32Enum undefined = (Int32Enum)123;
        var values = Enum.GetValues<Int32Enum>().Append(undefined);
        foreach (var x in values)
        {
            var expect = x.ToString();
            var actual = x.FastToString();
            actual.Should().Be(expect);
        }
    }
}



/// <summary>
/// Provides unit tests for enum based on <see cref="uint"/> type.
/// </summary>
[TestClass]
public sealed class UInt32Tests
{
    [TestMethod]
    public void GetUnderlyingType()
        => FastEnum.GetUnderlyingType<UInt32Enum>().Should().Be<uint>();


    [TestMethod]
    public void GetValues()
    {
        var expect = Enum.GetValues<UInt32Enum>();
        var actual = FastEnum.GetValues<UInt32Enum>();
        actual.Should().BeEquivalentTo(expect);
    }


    [TestMethod]
    public void GetNames()
    {
        var expect = Enum.GetNames<UInt32Enum>();
        var actual = FastEnum.GetNames<UInt32Enum>();
        actual.Should().BeEquivalentTo(expect);
    }


    [TestMethod]
    public void GetName()
    {
        //--- defined value
        {
            const UInt32Enum defined = UInt32Enum.MinValue;
            var expect = Enum.GetName(defined);
            var actual = FastEnum.GetName(defined);
            actual.Should().NotBeNull();
            actual.Should().BeEquivalentTo(expect);
        }
        //--- undefined value
        {
            const UInt32Enum undefined = (UInt32Enum)123;
            var expect = Enum.GetName(undefined);
            var actual = FastEnum.GetName(undefined);
            actual.Should().BeNull();
            actual.Should().BeEquivalentTo(expect);
        }
    }


    [TestMethod]
    public void GetMembers()
    {
        var expect
            = Enum.GetNames<UInt32Enum>()
            .Select(static name =>
            {
                var value = Enum.Parse<UInt32Enum>(name);
                var nameUtf8 = Encoding.UTF8.GetBytes(name);
                var fieldInfo = typeof(UInt32Enum).GetField(name);
                return (value, name, nameUtf8, fieldInfo);
            })
            .ToArray();
        var actual = FastEnum.GetMembers<UInt32Enum>();

        actual.Length.Should().Be(expect.Length);
        for (var i = 0; i < expect.Length; i++)
        {
            var a = actual[i];
            var e = expect[i];
            a.Value.Should().Be(e.value);
            a.Name.Should().Be(e.name);
            a.NameUtf8.Should().Equal(e.nameUtf8);
            a.FieldInfo.Should().Be(e.fieldInfo);

            var (name, value) = a;
            value.Should().Be(e.value);
            name.Should().Be(e.name);
        }
    }


    [TestMethod]
    public void GetMember()
    {
        //--- defined value
        {
            const UInt32Enum defined = UInt32Enum.MinValue;
            var expect = getMember(defined);
            var actual = FastEnum.GetMember(defined)!;

            actual.Should().NotBeNull();
            actual.Value.Should().Be(expect.value);
            actual.Name.Should().Be(expect.name);
            actual.NameUtf8.Should().Equal(expect.nameUtf8);
            actual.FieldInfo.Should().Be(expect.fieldInfo);

            var (name, value) = actual;
            value.Should().Be(expect.value);
            name.Should().Be(expect.name);
        }
        //--- undefined value
        {
            const UInt32Enum undefined = (UInt32Enum)123;
            var actual = FastEnum.GetMember(undefined);
            actual.Should().BeNull();
        }

        #region Local Functions
        static (T value, string name, byte[] nameUtf8, FieldInfo fieldInfo) getMember<T>(T value)
            where T : struct, Enum
        {
            var name = Enum.GetName<T>(value)!;
            var nameUtf8 = Encoding.UTF8.GetBytes(name);
            var fieldInfo = typeof(T).GetField(name)!;
            return (value, name, nameUtf8, fieldInfo);
        }
        #endregion
    }


    [TestMethod]
    public void GetMinValue()
    {
        var min = FastEnum.GetMinValue<UInt32Enum>();
        min.Should().NotBeNull();
        min.Should().Be(UInt32Enum.MinValue);
    }


    [TestMethod]
    public void GetMaxValue()
    {
        var max = FastEnum.GetMaxValue<UInt32Enum>();
        max.Should().NotBeNull();
        max.Should().Be(UInt32Enum.MaxValue);
    }


    [TestMethod]
    public void IsEmpty()
        => FastEnum.IsEmpty<UInt32Enum>().Should().Be(false);


    [TestMethod]
    public void IsContinuous()
        => FastEnum.IsContinuous<UInt32Enum>().Should().Be(false);


    [TestMethod]
    public void IsFlags()
        => FastEnum.IsFlags<UInt32Enum>().Should().Be(false);


    [TestMethod]
    public void IsDefined()
    {
        //--- IsDefined(TEnum)
        FastEnum.IsDefined<UInt32Enum>(UInt32Enum.MinValue).Should().BeTrue();
        FastEnum.IsDefined<UInt32Enum>(UInt32Enum.MaxValue).Should().BeTrue();
        FastEnum.IsDefined<UInt32Enum>((UInt32Enum)123).Should().BeFalse();

        //--- Extension methods
        UInt32Enum.MinValue.IsDefined().Should().BeTrue();
        UInt32Enum.MaxValue.IsDefined().Should().BeTrue();

        //--- IsDefined(ReadOnlySpan<char>)
        FastEnum.IsDefined<UInt32Enum>(nameof(UInt32Enum.MinValue)).Should().BeTrue();
        FastEnum.IsDefined<UInt32Enum>(nameof(UInt32Enum.MaxValue)).Should().BeTrue();
        FastEnum.IsDefined<UInt32Enum>("123").Should().BeFalse();
        FastEnum.IsDefined<UInt32Enum>("minvalue").Should().BeFalse();
    }


    [TestMethod]
    public void Parse()
    {
        var parameters = new[]
        {
            (value: UInt32Enum.MinValue, name: nameof(UInt32Enum.MinValue), valueString: ((uint)UInt32Enum.MinValue).ToString(CultureInfo.InvariantCulture)),
            (value: UInt32Enum.MaxValue, name: nameof(UInt32Enum.MaxValue), valueString: ((uint)UInt32Enum.MaxValue).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.Parse<UInt32Enum>(x.name).Should().Be(x.value);
            FluentActions.Invoking(() => FastEnum.Parse<UInt32Enum>(x.name.ToLower(CultureInfo.InvariantCulture))).Should().Throw<ArgumentException>();
            FluentActions.Invoking(() => FastEnum.Parse<UInt32Enum>(x.name.ToUpper(CultureInfo.InvariantCulture))).Should().Throw<ArgumentException>();
            FastEnum.Parse<UInt32Enum>(x.valueString).Should().Be(x.value);
            FastEnum.Parse<UInt32Enum>(x.valueString.ToLower(CultureInfo.InvariantCulture)).Should().Be(x.value);
            FastEnum.Parse<UInt32Enum>(x.valueString.ToUpper(CultureInfo.InvariantCulture)).Should().Be(x.value);
        }
        FluentActions.Invoking(static () => FastEnum.Parse<UInt32Enum>((string?)null, true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<UInt32Enum>("")).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<UInt32Enum>(" ")).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<UInt32Enum>("ABCDE")).Should().Throw<ArgumentException>();
        FastEnum.Parse<UInt32Enum>("123").Should().Be((UInt32Enum)123);
    }


    [TestMethod]
    public void ParseIgnoreCase()
    {
        var parameters = new[]
        {
            (value: UInt32Enum.MinValue, name: nameof(UInt32Enum.MinValue), valueString: ((uint)UInt32Enum.MinValue).ToString(CultureInfo.InvariantCulture)),
            (value: UInt32Enum.MaxValue, name: nameof(UInt32Enum.MaxValue), valueString: ((uint)UInt32Enum.MaxValue).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.Parse<UInt32Enum>(x.name, true).Should().Be(x.value);
            FastEnum.Parse<UInt32Enum>(x.name.ToLower(CultureInfo.InvariantCulture), true).Should().Be(x.value);
            FastEnum.Parse<UInt32Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), true).Should().Be(x.value);
            FastEnum.Parse<UInt32Enum>(x.valueString).Should().Be(x.value);
            FastEnum.Parse<UInt32Enum>(x.valueString.ToLower(CultureInfo.InvariantCulture), true).Should().Be(x.value);
            FastEnum.Parse<UInt32Enum>(x.valueString.ToUpper(CultureInfo.InvariantCulture), true).Should().Be(x.value);
        }
        FluentActions.Invoking(static () => FastEnum.Parse<UInt32Enum>((string?)null, true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<UInt32Enum>("", true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<UInt32Enum>(" ", true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<UInt32Enum>("ABCDE", true)).Should().Throw<ArgumentException>();
        FastEnum.Parse<UInt32Enum>("123").Should().Be((UInt32Enum)123);
    }


    [TestMethod]
    public void TryParse()
    {
        var parameters = new[]
        {
            (value: UInt32Enum.MinValue, name: nameof(UInt32Enum.MinValue), valueString: ((uint)UInt32Enum.MinValue).ToString(CultureInfo.InvariantCulture)),
            (value: UInt32Enum.MaxValue, name: nameof(UInt32Enum.MaxValue), valueString: ((uint)UInt32Enum.MaxValue).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.TryParse<UInt32Enum>(x.name, out var r1).Should().BeTrue();
            r1.Should().Be(x.value);

            FastEnum.TryParse<UInt32Enum>(x.name.ToLower(CultureInfo.InvariantCulture), out var _).Should().BeFalse();
            FastEnum.TryParse<UInt32Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), out var _).Should().BeFalse();

            FastEnum.TryParse<UInt32Enum>(x.valueString, out var r2).Should().BeTrue();
            r2.Should().Be(x.value);

            FastEnum.TryParse<UInt32Enum>(x.valueString.ToLower(CultureInfo.InvariantCulture), out var r3).Should().BeTrue();
            r3.Should().Be(x.value);

            FastEnum.TryParse<UInt32Enum>(x.valueString.ToUpper(CultureInfo.InvariantCulture), out var r4).Should().BeTrue();
            r4.Should().Be(x.value);
        }
        FastEnum.TryParse<UInt32Enum>((string?)null, out var _).Should().BeFalse();
        FastEnum.TryParse<UInt32Enum>("", out var _).Should().BeFalse();
        FastEnum.TryParse<UInt32Enum>(" ", out var _).Should().BeFalse();
        FastEnum.TryParse<UInt32Enum>("ABCDE", out var _).Should().BeFalse();
        FastEnum.TryParse<UInt32Enum>("123", out var r).Should().BeTrue();
        r.Should().Be((UInt32Enum)123);
    }


    [TestMethod]
    public void TryParseIgnoreCase()
    {
        var parameters = new[]
        {
            (value: UInt32Enum.MinValue, name: nameof(UInt32Enum.MinValue), valueString: ((uint)UInt32Enum.MinValue).ToString(CultureInfo.InvariantCulture)),
            (value: UInt32Enum.MaxValue, name: nameof(UInt32Enum.MaxValue), valueString: ((uint)UInt32Enum.MaxValue).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.TryParse<UInt32Enum>(x.name, true, out var r1).Should().BeTrue();
            r1.Should().Be(x.value);

            FastEnum.TryParse<UInt32Enum>(x.name.ToLower(CultureInfo.InvariantCulture), true, out var r2).Should().BeTrue();
            r2.Should().Be(x.value);

            FastEnum.TryParse<UInt32Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), true, out var r3).Should().BeTrue();
            r3.Should().Be(x.value);

            FastEnum.TryParse<UInt32Enum>(x.valueString, true, out var r4).Should().BeTrue();
            r4.Should().Be(x.value);

            FastEnum.TryParse<UInt32Enum>(x.valueString.ToLower(CultureInfo.InvariantCulture), true, out var r5).Should().BeTrue();
            r5.Should().Be(x.value);

            FastEnum.TryParse<UInt32Enum>(x.valueString.ToUpper(CultureInfo.InvariantCulture), true, out var r6).Should().BeTrue();
            r6.Should().Be(x.value);
        }
        FastEnum.TryParse<UInt32Enum>((string?)null, true, out var _).Should().BeFalse();
        FastEnum.TryParse<UInt32Enum>("", true, out var _).Should().BeFalse();
        FastEnum.TryParse<UInt32Enum>(" ", true, out var _).Should().BeFalse();
        FastEnum.TryParse<UInt32Enum>("ABCDE", true, out var _).Should().BeFalse();
        FastEnum.TryParse<UInt32Enum>("123", true, out var r).Should().BeTrue();
        r.Should().Be((UInt32Enum)123);
    }


    [TestMethod]
    public void ToMember()
    {
        var value = UInt32Enum.MaxValue;
        var name = nameof(UInt32Enum.MaxValue);
        var nameUtf8 = Encoding.UTF8.GetBytes(name);
        var member = value.ToMember()!;
        var info = typeof(UInt32Enum).GetField(name);

        member.Should().NotBeNull();
        member.Name.Should().Be(name);
        member.NameUtf8.Should().Equal(nameUtf8);
        member.Value.Should().Be(value);
        member.FieldInfo.Should().Be(info);
    }


    [TestMethod]
    public void ToName()
    {
        UInt32Enum.MinValue.ToName().Should().Be(nameof(UInt32Enum.MinValue));
        UInt32Enum.MaxValue.ToName().Should().Be(nameof(UInt32Enum.MaxValue));
    }


    [TestMethod]
    public void ToUnderlying()
    {
        var @enum = UInt32Enum.MinValue;
        var value = uint.MinValue;

        FluentActions.Invoking(() => @enum.ToSByte()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToByte()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToInt16()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToUInt16()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToInt32()).Should().Throw<ArgumentException>();
        @enum.ToUInt32().Should().Be(value);
        FluentActions.Invoking(() => @enum.ToInt64()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToUInt64()).Should().Throw<ArgumentException>();
    }


    [TestMethod]
    public void FastToString()
    {
        const UInt32Enum undefined = (UInt32Enum)123;
        var values = Enum.GetValues<UInt32Enum>().Append(undefined);
        foreach (var x in values)
        {
            var expect = x.ToString();
            var actual = x.FastToString();
            actual.Should().Be(expect);
        }
    }
}



/// <summary>
/// Provides unit tests for enum based on <see cref="long"/> type.
/// </summary>
[TestClass]
public sealed class Int64Tests
{
    [TestMethod]
    public void GetUnderlyingType()
        => FastEnum.GetUnderlyingType<Int64Enum>().Should().Be<long>();


    [TestMethod]
    public void GetValues()
    {
        var expect = Enum.GetValues<Int64Enum>();
        var actual = FastEnum.GetValues<Int64Enum>();
        actual.Should().BeEquivalentTo(expect);
    }


    [TestMethod]
    public void GetNames()
    {
        var expect = Enum.GetNames<Int64Enum>();
        var actual = FastEnum.GetNames<Int64Enum>();
        actual.Should().BeEquivalentTo(expect);
    }


    [TestMethod]
    public void GetName()
    {
        //--- defined value
        {
            const Int64Enum defined = Int64Enum.MinValue;
            var expect = Enum.GetName(defined);
            var actual = FastEnum.GetName(defined);
            actual.Should().NotBeNull();
            actual.Should().BeEquivalentTo(expect);
        }
        //--- undefined value
        {
            const Int64Enum undefined = (Int64Enum)123;
            var expect = Enum.GetName(undefined);
            var actual = FastEnum.GetName(undefined);
            actual.Should().BeNull();
            actual.Should().BeEquivalentTo(expect);
        }
    }


    [TestMethod]
    public void GetMembers()
    {
        var expect
            = Enum.GetNames<Int64Enum>()
            .Select(static name =>
            {
                var value = Enum.Parse<Int64Enum>(name);
                var nameUtf8 = Encoding.UTF8.GetBytes(name);
                var fieldInfo = typeof(Int64Enum).GetField(name);
                return (value, name, nameUtf8, fieldInfo);
            })
            .ToArray();
        var actual = FastEnum.GetMembers<Int64Enum>();

        actual.Length.Should().Be(expect.Length);
        for (var i = 0; i < expect.Length; i++)
        {
            var a = actual[i];
            var e = expect[i];
            a.Value.Should().Be(e.value);
            a.Name.Should().Be(e.name);
            a.NameUtf8.Should().Equal(e.nameUtf8);
            a.FieldInfo.Should().Be(e.fieldInfo);

            var (name, value) = a;
            value.Should().Be(e.value);
            name.Should().Be(e.name);
        }
    }


    [TestMethod]
    public void GetMember()
    {
        //--- defined value
        {
            const Int64Enum defined = Int64Enum.MinValue;
            var expect = getMember(defined);
            var actual = FastEnum.GetMember(defined)!;

            actual.Should().NotBeNull();
            actual.Value.Should().Be(expect.value);
            actual.Name.Should().Be(expect.name);
            actual.NameUtf8.Should().Equal(expect.nameUtf8);
            actual.FieldInfo.Should().Be(expect.fieldInfo);

            var (name, value) = actual;
            value.Should().Be(expect.value);
            name.Should().Be(expect.name);
        }
        //--- undefined value
        {
            const Int64Enum undefined = (Int64Enum)123;
            var actual = FastEnum.GetMember(undefined);
            actual.Should().BeNull();
        }

        #region Local Functions
        static (T value, string name, byte[] nameUtf8, FieldInfo fieldInfo) getMember<T>(T value)
            where T : struct, Enum
        {
            var name = Enum.GetName<T>(value)!;
            var nameUtf8 = Encoding.UTF8.GetBytes(name);
            var fieldInfo = typeof(T).GetField(name)!;
            return (value, name, nameUtf8, fieldInfo);
        }
        #endregion
    }


    [TestMethod]
    public void GetMinValue()
    {
        var min = FastEnum.GetMinValue<Int64Enum>();
        min.Should().NotBeNull();
        min.Should().Be(Int64Enum.MinValue);
    }


    [TestMethod]
    public void GetMaxValue()
    {
        var max = FastEnum.GetMaxValue<Int64Enum>();
        max.Should().NotBeNull();
        max.Should().Be(Int64Enum.MaxValue);
    }


    [TestMethod]
    public void IsEmpty()
        => FastEnum.IsEmpty<Int64Enum>().Should().Be(false);


    [TestMethod]
    public void IsContinuous()
        => FastEnum.IsContinuous<Int64Enum>().Should().Be(false);


    [TestMethod]
    public void IsFlags()
        => FastEnum.IsFlags<Int64Enum>().Should().Be(false);


    [TestMethod]
    public void IsDefined()
    {
        //--- IsDefined(TEnum)
        FastEnum.IsDefined<Int64Enum>(Int64Enum.MinValue).Should().BeTrue();
        FastEnum.IsDefined<Int64Enum>(Int64Enum.Zero).Should().BeTrue();
        FastEnum.IsDefined<Int64Enum>(Int64Enum.MaxValue).Should().BeTrue();
        FastEnum.IsDefined<Int64Enum>((Int64Enum)123).Should().BeFalse();

        //--- Extension methods
        Int64Enum.MinValue.IsDefined().Should().BeTrue();
        Int64Enum.Zero.IsDefined().Should().BeTrue();
        Int64Enum.MaxValue.IsDefined().Should().BeTrue();

        //--- IsDefined(ReadOnlySpan<char>)
        FastEnum.IsDefined<Int64Enum>(nameof(Int64Enum.MinValue)).Should().BeTrue();
        FastEnum.IsDefined<Int64Enum>(nameof(Int64Enum.Zero)).Should().BeTrue();
        FastEnum.IsDefined<Int64Enum>(nameof(Int64Enum.MaxValue)).Should().BeTrue();
        FastEnum.IsDefined<Int64Enum>("123").Should().BeFalse();
        FastEnum.IsDefined<Int64Enum>("minvalue").Should().BeFalse();
    }


    [TestMethod]
    public void Parse()
    {
        var parameters = new[]
        {
            (value: Int64Enum.MinValue, name: nameof(Int64Enum.MinValue), valueString: ((long)Int64Enum.MinValue).ToString(CultureInfo.InvariantCulture)),
            (value: Int64Enum.Zero,     name: nameof(Int64Enum.Zero),     valueString: ((long)Int64Enum.Zero).ToString(CultureInfo.InvariantCulture)),
            (value: Int64Enum.MaxValue, name: nameof(Int64Enum.MaxValue), valueString: ((long)Int64Enum.MaxValue).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.Parse<Int64Enum>(x.name).Should().Be(x.value);
            FluentActions.Invoking(() => FastEnum.Parse<Int64Enum>(x.name.ToLower(CultureInfo.InvariantCulture))).Should().Throw<ArgumentException>();
            FluentActions.Invoking(() => FastEnum.Parse<Int64Enum>(x.name.ToUpper(CultureInfo.InvariantCulture))).Should().Throw<ArgumentException>();
            FastEnum.Parse<Int64Enum>(x.valueString).Should().Be(x.value);
            FastEnum.Parse<Int64Enum>(x.valueString.ToLower(CultureInfo.InvariantCulture)).Should().Be(x.value);
            FastEnum.Parse<Int64Enum>(x.valueString.ToUpper(CultureInfo.InvariantCulture)).Should().Be(x.value);
        }
        FluentActions.Invoking(static () => FastEnum.Parse<Int64Enum>((string?)null, true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<Int64Enum>("")).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<Int64Enum>(" ")).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<Int64Enum>("ABCDE")).Should().Throw<ArgumentException>();
        FastEnum.Parse<Int64Enum>("123").Should().Be((Int64Enum)123);
    }


    [TestMethod]
    public void ParseIgnoreCase()
    {
        var parameters = new[]
        {
            (value: Int64Enum.MinValue, name: nameof(Int64Enum.MinValue), valueString: ((long)Int64Enum.MinValue).ToString(CultureInfo.InvariantCulture)),
            (value: Int64Enum.Zero,     name: nameof(Int64Enum.Zero),     valueString: ((long)Int64Enum.Zero).ToString(CultureInfo.InvariantCulture)),
            (value: Int64Enum.MaxValue, name: nameof(Int64Enum.MaxValue), valueString: ((long)Int64Enum.MaxValue).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.Parse<Int64Enum>(x.name, true).Should().Be(x.value);
            FastEnum.Parse<Int64Enum>(x.name.ToLower(CultureInfo.InvariantCulture), true).Should().Be(x.value);
            FastEnum.Parse<Int64Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), true).Should().Be(x.value);
            FastEnum.Parse<Int64Enum>(x.valueString).Should().Be(x.value);
            FastEnum.Parse<Int64Enum>(x.valueString.ToLower(CultureInfo.InvariantCulture), true).Should().Be(x.value);
            FastEnum.Parse<Int64Enum>(x.valueString.ToUpper(CultureInfo.InvariantCulture), true).Should().Be(x.value);
        }
        FluentActions.Invoking(static () => FastEnum.Parse<Int64Enum>((string?)null, true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<Int64Enum>("", true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<Int64Enum>(" ", true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<Int64Enum>("ABCDE", true)).Should().Throw<ArgumentException>();
        FastEnum.Parse<Int64Enum>("123").Should().Be((Int64Enum)123);
    }


    [TestMethod]
    public void TryParse()
    {
        var parameters = new[]
        {
            (value: Int64Enum.MinValue, name: nameof(Int64Enum.MinValue), valueString: ((long)Int64Enum.MinValue).ToString(CultureInfo.InvariantCulture)),
            (value: Int64Enum.Zero,     name: nameof(Int64Enum.Zero),     valueString: ((long)Int64Enum.Zero).ToString(CultureInfo.InvariantCulture)),
            (value: Int64Enum.MaxValue, name: nameof(Int64Enum.MaxValue), valueString: ((long)Int64Enum.MaxValue).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.TryParse<Int64Enum>(x.name, out var r1).Should().BeTrue();
            r1.Should().Be(x.value);

            FastEnum.TryParse<Int64Enum>(x.name.ToLower(CultureInfo.InvariantCulture), out var _).Should().BeFalse();
            FastEnum.TryParse<Int64Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), out var _).Should().BeFalse();

            FastEnum.TryParse<Int64Enum>(x.valueString, out var r2).Should().BeTrue();
            r2.Should().Be(x.value);

            FastEnum.TryParse<Int64Enum>(x.valueString.ToLower(CultureInfo.InvariantCulture), out var r3).Should().BeTrue();
            r3.Should().Be(x.value);

            FastEnum.TryParse<Int64Enum>(x.valueString.ToUpper(CultureInfo.InvariantCulture), out var r4).Should().BeTrue();
            r4.Should().Be(x.value);
        }
        FastEnum.TryParse<Int64Enum>((string?)null, out var _).Should().BeFalse();
        FastEnum.TryParse<Int64Enum>("", out var _).Should().BeFalse();
        FastEnum.TryParse<Int64Enum>(" ", out var _).Should().BeFalse();
        FastEnum.TryParse<Int64Enum>("ABCDE", out var _).Should().BeFalse();
        FastEnum.TryParse<Int64Enum>("123", out var r).Should().BeTrue();
        r.Should().Be((Int64Enum)123);
    }


    [TestMethod]
    public void TryParseIgnoreCase()
    {
        var parameters = new[]
        {
            (value: Int64Enum.MinValue, name: nameof(Int64Enum.MinValue), valueString: ((long)Int64Enum.MinValue).ToString(CultureInfo.InvariantCulture)),
            (value: Int64Enum.Zero,     name: nameof(Int64Enum.Zero),     valueString: ((long)Int64Enum.Zero).ToString(CultureInfo.InvariantCulture)),
            (value: Int64Enum.MaxValue, name: nameof(Int64Enum.MaxValue), valueString: ((long)Int64Enum.MaxValue).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.TryParse<Int64Enum>(x.name, true, out var r1).Should().BeTrue();
            r1.Should().Be(x.value);

            FastEnum.TryParse<Int64Enum>(x.name.ToLower(CultureInfo.InvariantCulture), true, out var r2).Should().BeTrue();
            r2.Should().Be(x.value);

            FastEnum.TryParse<Int64Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), true, out var r3).Should().BeTrue();
            r3.Should().Be(x.value);

            FastEnum.TryParse<Int64Enum>(x.valueString, true, out var r4).Should().BeTrue();
            r4.Should().Be(x.value);

            FastEnum.TryParse<Int64Enum>(x.valueString.ToLower(CultureInfo.InvariantCulture), true, out var r5).Should().BeTrue();
            r5.Should().Be(x.value);

            FastEnum.TryParse<Int64Enum>(x.valueString.ToUpper(CultureInfo.InvariantCulture), true, out var r6).Should().BeTrue();
            r6.Should().Be(x.value);
        }
        FastEnum.TryParse<Int64Enum>((string?)null, true, out var _).Should().BeFalse();
        FastEnum.TryParse<Int64Enum>("", true, out var _).Should().BeFalse();
        FastEnum.TryParse<Int64Enum>(" ", true, out var _).Should().BeFalse();
        FastEnum.TryParse<Int64Enum>("ABCDE", true, out var _).Should().BeFalse();
        FastEnum.TryParse<Int64Enum>("123", true, out var r).Should().BeTrue();
        r.Should().Be((Int64Enum)123);
    }


    [TestMethod]
    public void ToMember()
    {
        var value = Int64Enum.MaxValue;
        var name = nameof(Int64Enum.MaxValue);
        var nameUtf8 = Encoding.UTF8.GetBytes(name);
        var member = value.ToMember()!;
        var info = typeof(Int64Enum).GetField(name);

        member.Should().NotBeNull();
        member.Name.Should().Be(name);
        member.NameUtf8.Should().Equal(nameUtf8);
        member.Value.Should().Be(value);
        member.FieldInfo.Should().Be(info);
    }


    [TestMethod]
    public void ToName()
    {
        Int64Enum.MinValue.ToName().Should().Be(nameof(Int64Enum.MinValue));
        Int64Enum.Zero.ToName().Should().Be(nameof(Int64Enum.Zero));
        Int64Enum.MaxValue.ToName().Should().Be(nameof(Int64Enum.MaxValue));
    }


    [TestMethod]
    public void ToUnderlying()
    {
        var @enum = Int64Enum.MinValue;
        var value = long.MinValue;

        FluentActions.Invoking(() => @enum.ToSByte()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToByte()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToInt16()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToUInt16()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToInt32()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToUInt32()).Should().Throw<ArgumentException>();
        @enum.ToInt64().Should().Be(value);
        FluentActions.Invoking(() => @enum.ToUInt64()).Should().Throw<ArgumentException>();
    }


    [TestMethod]
    public void FastToString()
    {
        const Int64Enum undefined = (Int64Enum)123;
        var values = Enum.GetValues<Int64Enum>().Append(undefined);
        foreach (var x in values)
        {
            var expect = x.ToString();
            var actual = x.FastToString();
            actual.Should().Be(expect);
        }
    }
}



/// <summary>
/// Provides unit tests for enum based on <see cref="ulong"/> type.
/// </summary>
[TestClass]
public sealed class UInt64Tests
{
    [TestMethod]
    public void GetUnderlyingType()
        => FastEnum.GetUnderlyingType<UInt64Enum>().Should().Be<ulong>();


    [TestMethod]
    public void GetValues()
    {
        var expect = Enum.GetValues<UInt64Enum>();
        var actual = FastEnum.GetValues<UInt64Enum>();
        actual.Should().BeEquivalentTo(expect);
    }


    [TestMethod]
    public void GetNames()
    {
        var expect = Enum.GetNames<UInt64Enum>();
        var actual = FastEnum.GetNames<UInt64Enum>();
        actual.Should().BeEquivalentTo(expect);
    }


    [TestMethod]
    public void GetName()
    {
        //--- defined value
        {
            const UInt64Enum defined = UInt64Enum.MinValue;
            var expect = Enum.GetName(defined);
            var actual = FastEnum.GetName(defined);
            actual.Should().NotBeNull();
            actual.Should().BeEquivalentTo(expect);
        }
        //--- undefined value
        {
            const UInt64Enum undefined = (UInt64Enum)123;
            var expect = Enum.GetName(undefined);
            var actual = FastEnum.GetName(undefined);
            actual.Should().BeNull();
            actual.Should().BeEquivalentTo(expect);
        }
    }


    [TestMethod]
    public void GetMembers()
    {
        var expect
            = Enum.GetNames<UInt64Enum>()
            .Select(static name =>
            {
                var value = Enum.Parse<UInt64Enum>(name);
                var nameUtf8 = Encoding.UTF8.GetBytes(name);
                var fieldInfo = typeof(UInt64Enum).GetField(name);
                return (value, name, nameUtf8, fieldInfo);
            })
            .ToArray();
        var actual = FastEnum.GetMembers<UInt64Enum>();

        actual.Length.Should().Be(expect.Length);
        for (var i = 0; i < expect.Length; i++)
        {
            var a = actual[i];
            var e = expect[i];
            a.Value.Should().Be(e.value);
            a.Name.Should().Be(e.name);
            a.NameUtf8.Should().Equal(e.nameUtf8);
            a.FieldInfo.Should().Be(e.fieldInfo);

            var (name, value) = a;
            value.Should().Be(e.value);
            name.Should().Be(e.name);
        }
    }


    [TestMethod]
    public void GetMember()
    {
        //--- defined value
        {
            const UInt64Enum defined = UInt64Enum.MinValue;
            var expect = getMember(defined);
            var actual = FastEnum.GetMember(defined)!;

            actual.Should().NotBeNull();
            actual.Value.Should().Be(expect.value);
            actual.Name.Should().Be(expect.name);
            actual.NameUtf8.Should().Equal(expect.nameUtf8);
            actual.FieldInfo.Should().Be(expect.fieldInfo);

            var (name, value) = actual;
            value.Should().Be(expect.value);
            name.Should().Be(expect.name);
        }
        //--- undefined value
        {
            const UInt64Enum undefined = (UInt64Enum)123;
            var actual = FastEnum.GetMember(undefined);
            actual.Should().BeNull();
        }

        #region Local Functions
        static (T value, string name, byte[] nameUtf8, FieldInfo fieldInfo) getMember<T>(T value)
            where T : struct, Enum
        {
            var name = Enum.GetName<T>(value)!;
            var nameUtf8 = Encoding.UTF8.GetBytes(name);
            var fieldInfo = typeof(T).GetField(name)!;
            return (value, name, nameUtf8, fieldInfo);
        }
        #endregion
    }


    [TestMethod]
    public void GetMinValue()
    {
        var min = FastEnum.GetMinValue<UInt64Enum>();
        min.Should().NotBeNull();
        min.Should().Be(UInt64Enum.MinValue);
    }


    [TestMethod]
    public void GetMaxValue()
    {
        var max = FastEnum.GetMaxValue<UInt64Enum>();
        max.Should().NotBeNull();
        max.Should().Be(UInt64Enum.MaxValue);
    }


    [TestMethod]
    public void IsEmpty()
        => FastEnum.IsEmpty<UInt64Enum>().Should().Be(false);


    [TestMethod]
    public void IsContinuous()
        => FastEnum.IsContinuous<UInt64Enum>().Should().Be(false);


    [TestMethod]
    public void IsFlags()
        => FastEnum.IsFlags<UInt64Enum>().Should().Be(false);


    [TestMethod]
    public void IsDefined()
    {
        //--- IsDefined(TEnum)
        FastEnum.IsDefined<UInt64Enum>(UInt64Enum.MinValue).Should().BeTrue();
        FastEnum.IsDefined<UInt64Enum>(UInt64Enum.MaxValue).Should().BeTrue();
        FastEnum.IsDefined<UInt64Enum>((UInt64Enum)123).Should().BeFalse();

        //--- Extension methods
        UInt64Enum.MinValue.IsDefined().Should().BeTrue();
        UInt64Enum.MaxValue.IsDefined().Should().BeTrue();

        //--- IsDefined(ReadOnlySpan<char>)
        FastEnum.IsDefined<UInt64Enum>(nameof(UInt64Enum.MinValue)).Should().BeTrue();
        FastEnum.IsDefined<UInt64Enum>(nameof(UInt64Enum.MaxValue)).Should().BeTrue();
        FastEnum.IsDefined<UInt64Enum>("123").Should().BeFalse();
        FastEnum.IsDefined<UInt64Enum>("minvalue").Should().BeFalse();
    }


    [TestMethod]
    public void Parse()
    {
        var parameters = new[]
        {
            (value: UInt64Enum.MinValue, name: nameof(UInt64Enum.MinValue), valueString: ((ulong)UInt64Enum.MinValue).ToString(CultureInfo.InvariantCulture)),
            (value: UInt64Enum.MaxValue, name: nameof(UInt64Enum.MaxValue), valueString: ((ulong)UInt64Enum.MaxValue).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.Parse<UInt64Enum>(x.name).Should().Be(x.value);
            FluentActions.Invoking(() => FastEnum.Parse<UInt64Enum>(x.name.ToLower(CultureInfo.InvariantCulture))).Should().Throw<ArgumentException>();
            FluentActions.Invoking(() => FastEnum.Parse<UInt64Enum>(x.name.ToUpper(CultureInfo.InvariantCulture))).Should().Throw<ArgumentException>();
            FastEnum.Parse<UInt64Enum>(x.valueString).Should().Be(x.value);
            FastEnum.Parse<UInt64Enum>(x.valueString.ToLower(CultureInfo.InvariantCulture)).Should().Be(x.value);
            FastEnum.Parse<UInt64Enum>(x.valueString.ToUpper(CultureInfo.InvariantCulture)).Should().Be(x.value);
        }
        FluentActions.Invoking(static () => FastEnum.Parse<UInt64Enum>((string?)null, true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<UInt64Enum>("")).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<UInt64Enum>(" ")).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<UInt64Enum>("ABCDE")).Should().Throw<ArgumentException>();
        FastEnum.Parse<UInt64Enum>("123").Should().Be((UInt64Enum)123);
    }


    [TestMethod]
    public void ParseIgnoreCase()
    {
        var parameters = new[]
        {
            (value: UInt64Enum.MinValue, name: nameof(UInt64Enum.MinValue), valueString: ((ulong)UInt64Enum.MinValue).ToString(CultureInfo.InvariantCulture)),
            (value: UInt64Enum.MaxValue, name: nameof(UInt64Enum.MaxValue), valueString: ((ulong)UInt64Enum.MaxValue).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.Parse<UInt64Enum>(x.name, true).Should().Be(x.value);
            FastEnum.Parse<UInt64Enum>(x.name.ToLower(CultureInfo.InvariantCulture), true).Should().Be(x.value);
            FastEnum.Parse<UInt64Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), true).Should().Be(x.value);
            FastEnum.Parse<UInt64Enum>(x.valueString).Should().Be(x.value);
            FastEnum.Parse<UInt64Enum>(x.valueString.ToLower(CultureInfo.InvariantCulture), true).Should().Be(x.value);
            FastEnum.Parse<UInt64Enum>(x.valueString.ToUpper(CultureInfo.InvariantCulture), true).Should().Be(x.value);
        }
        FluentActions.Invoking(static () => FastEnum.Parse<UInt64Enum>((string?)null, true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<UInt64Enum>("", true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<UInt64Enum>(" ", true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<UInt64Enum>("ABCDE", true)).Should().Throw<ArgumentException>();
        FastEnum.Parse<UInt64Enum>("123").Should().Be((UInt64Enum)123);
    }


    [TestMethod]
    public void TryParse()
    {
        var parameters = new[]
        {
            (value: UInt64Enum.MinValue, name: nameof(UInt64Enum.MinValue), valueString: ((ulong)UInt64Enum.MinValue).ToString(CultureInfo.InvariantCulture)),
            (value: UInt64Enum.MaxValue, name: nameof(UInt64Enum.MaxValue), valueString: ((ulong)UInt64Enum.MaxValue).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.TryParse<UInt64Enum>(x.name, out var r1).Should().BeTrue();
            r1.Should().Be(x.value);

            FastEnum.TryParse<UInt64Enum>(x.name.ToLower(CultureInfo.InvariantCulture), out var _).Should().BeFalse();
            FastEnum.TryParse<UInt64Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), out var _).Should().BeFalse();

            FastEnum.TryParse<UInt64Enum>(x.valueString, out var r2).Should().BeTrue();
            r2.Should().Be(x.value);

            FastEnum.TryParse<UInt64Enum>(x.valueString.ToLower(CultureInfo.InvariantCulture), out var r3).Should().BeTrue();
            r3.Should().Be(x.value);

            FastEnum.TryParse<UInt64Enum>(x.valueString.ToUpper(CultureInfo.InvariantCulture), out var r4).Should().BeTrue();
            r4.Should().Be(x.value);
        }
        FastEnum.TryParse<UInt64Enum>((string?)null, out var _).Should().BeFalse();
        FastEnum.TryParse<UInt64Enum>("", out var _).Should().BeFalse();
        FastEnum.TryParse<UInt64Enum>(" ", out var _).Should().BeFalse();
        FastEnum.TryParse<UInt64Enum>("ABCDE", out var _).Should().BeFalse();
        FastEnum.TryParse<UInt64Enum>("123", out var r).Should().BeTrue();
        r.Should().Be((UInt64Enum)123);
    }


    [TestMethod]
    public void TryParseIgnoreCase()
    {
        var parameters = new[]
        {
            (value: UInt64Enum.MinValue, name: nameof(UInt64Enum.MinValue), valueString: ((ulong)UInt64Enum.MinValue).ToString(CultureInfo.InvariantCulture)),
            (value: UInt64Enum.MaxValue, name: nameof(UInt64Enum.MaxValue), valueString: ((ulong)UInt64Enum.MaxValue).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.TryParse<UInt64Enum>(x.name, true, out var r1).Should().BeTrue();
            r1.Should().Be(x.value);

            FastEnum.TryParse<UInt64Enum>(x.name.ToLower(CultureInfo.InvariantCulture), true, out var r2).Should().BeTrue();
            r2.Should().Be(x.value);

            FastEnum.TryParse<UInt64Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), true, out var r3).Should().BeTrue();
            r3.Should().Be(x.value);

            FastEnum.TryParse<UInt64Enum>(x.valueString, true, out var r4).Should().BeTrue();
            r4.Should().Be(x.value);

            FastEnum.TryParse<UInt64Enum>(x.valueString.ToLower(CultureInfo.InvariantCulture), true, out var r5).Should().BeTrue();
            r5.Should().Be(x.value);

            FastEnum.TryParse<UInt64Enum>(x.valueString.ToUpper(CultureInfo.InvariantCulture), true, out var r6).Should().BeTrue();
            r6.Should().Be(x.value);
        }
        FastEnum.TryParse<UInt64Enum>((string?)null, true, out var _).Should().BeFalse();
        FastEnum.TryParse<UInt64Enum>("", true, out var _).Should().BeFalse();
        FastEnum.TryParse<UInt64Enum>(" ", true, out var _).Should().BeFalse();
        FastEnum.TryParse<UInt64Enum>("ABCDE", true, out var _).Should().BeFalse();
        FastEnum.TryParse<UInt64Enum>("123", true, out var r).Should().BeTrue();
        r.Should().Be((UInt64Enum)123);
    }


    [TestMethod]
    public void ToMember()
    {
        var value = UInt64Enum.MaxValue;
        var name = nameof(UInt64Enum.MaxValue);
        var nameUtf8 = Encoding.UTF8.GetBytes(name);
        var member = value.ToMember()!;
        var info = typeof(UInt64Enum).GetField(name);

        member.Should().NotBeNull();
        member.Name.Should().Be(name);
        member.NameUtf8.Should().Equal(nameUtf8);
        member.Value.Should().Be(value);
        member.FieldInfo.Should().Be(info);
    }


    [TestMethod]
    public void ToName()
    {
        UInt64Enum.MinValue.ToName().Should().Be(nameof(UInt64Enum.MinValue));
        UInt64Enum.MaxValue.ToName().Should().Be(nameof(UInt64Enum.MaxValue));
    }


    [TestMethod]
    public void ToUnderlying()
    {
        var @enum = UInt64Enum.MinValue;
        var value = ulong.MinValue;

        FluentActions.Invoking(() => @enum.ToSByte()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToByte()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToInt16()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToUInt16()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToInt32()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToUInt32()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToInt64()).Should().Throw<ArgumentException>();
        @enum.ToUInt64().Should().Be(value);
    }


    [TestMethod]
    public void FastToString()
    {
        const UInt64Enum undefined = (UInt64Enum)123;
        var values = Enum.GetValues<UInt64Enum>().Append(undefined);
        foreach (var x in values)
        {
            var expect = x.ToString();
            var actual = x.FastToString();
            actual.Should().Be(expect);
        }
    }
}



