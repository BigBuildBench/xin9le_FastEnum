<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
    var parameters = new[]
    {
        new { EnumType = "SByteEnum",  UnderlyingType = "sbyte",  AliasType = "SByte",  ConjugateType = "byte",   IsSignedType = true,  BoosterType = "SByteEnumBooster"  },
        new { EnumType = "ByteEnum",   UnderlyingType = "byte",   AliasType = "Byte",   ConjugateType = "sbyte",  IsSignedType = false, BoosterType = "ByteEnumBooster"   },
        new { EnumType = "Int16Enum",  UnderlyingType = "short",  AliasType = "Int16",  ConjugateType = "ushort", IsSignedType = true,  BoosterType = "Int16EnumBooster"  },
        new { EnumType = "UInt16Enum", UnderlyingType = "ushort", AliasType = "UInt16", ConjugateType = "short",  IsSignedType = false, BoosterType = "UInt16EnumBooster" },
        new { EnumType = "Int32Enum",  UnderlyingType = "int",    AliasType = "Int32",  ConjugateType = "uint",   IsSignedType = true,  BoosterType = "Int32EnumBooster"  },
        new { EnumType = "UInt32Enum", UnderlyingType = "uint",   AliasType = "UInt32", ConjugateType = "int",    IsSignedType = false, BoosterType = "UInt32EnumBooster" },
        new { EnumType = "Int64Enum",  UnderlyingType = "long",   AliasType = "Int64",  ConjugateType = "ulong",  IsSignedType = true,  BoosterType = "Int64EnumBooster"  },
        new { EnumType = "UInt64Enum", UnderlyingType = "ulong",  AliasType = "UInt64", ConjugateType = "long",   IsSignedType = false, BoosterType = "UInt64EnumBooster" },
    };
#>
// <auto-generated>
// This .cs file is generated by T4 template. Don't change it. Change the .tt file instead.
// </auto-generated>
#nullable enable

using System;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Text;
using FastEnumUtility.UnitTests.Models;
using FluentAssertions;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace FastEnumUtility.UnitTests.Cases.Generators;



<# foreach (var x in parameters) { #>
/// <summary>
/// Provides unit tests for enum based on <see cref="<#= x.UnderlyingType #>"/> type.
/// </summary>
[TestClass]
public sealed class <#= x.AliasType #>Tests
{
    [TestMethod]
    public void GetName()
    {
        //--- defined value
        {
            const <#= x.EnumType #> defined = <#= x.EnumType #>.MinValue;
            var expect = Enum.GetName(defined);
            var actual = FastEnum.GetName<<#= x.EnumType #>, <#= x.BoosterType #>>(defined);
            actual.Should().NotBeNull();
            actual.Should().BeEquivalentTo(expect);
        }
        //--- undefined value
        {
            const <#= x.EnumType #> undefined = (<#= x.EnumType #>)123;
            var expect = Enum.GetName(undefined);
            var actual = FastEnum.GetName<<#= x.EnumType #>, <#= x.BoosterType #>>(undefined);
            actual.Should().BeNull();
            actual.Should().BeEquivalentTo(expect);
        }
    }


    [TestMethod]
    public void IsDefined()
    {
        //--- IsDefined(TEnum)
        FastEnum.IsDefined<<#= x.EnumType #>, <#= x.BoosterType #>>(<#= x.EnumType #>.MinValue).Should().BeTrue();
<# if (x.IsSignedType) { #>
        FastEnum.IsDefined<<#= x.EnumType #>, <#= x.BoosterType #>>(<#= x.EnumType #>.Zero).Should().BeTrue();
<# } #>
        FastEnum.IsDefined<<#= x.EnumType #>, <#= x.BoosterType #>>(<#= x.EnumType #>.MaxValue).Should().BeTrue();
        FastEnum.IsDefined<<#= x.EnumType #>, <#= x.BoosterType #>>((<#= x.EnumType #>)123).Should().BeFalse();

        //--- IsDefined(ReadOnlySpan<char>)
        FastEnum.IsDefined<<#= x.EnumType #>, <#= x.BoosterType #>>(nameof(<#= x.EnumType #>.MinValue)).Should().BeTrue();
<# if (x.IsSignedType) { #>
        FastEnum.IsDefined<<#= x.EnumType #>, <#= x.BoosterType #>>(nameof(<#= x.EnumType #>.Zero)).Should().BeTrue();
<# } #>
        FastEnum.IsDefined<<#= x.EnumType #>, <#= x.BoosterType #>>(nameof(<#= x.EnumType #>.MaxValue)).Should().BeTrue();
        FastEnum.IsDefined<<#= x.EnumType #>, <#= x.BoosterType #>>("123").Should().BeFalse();
        FastEnum.IsDefined<<#= x.EnumType #>, <#= x.BoosterType #>>("minvalue").Should().BeFalse();
    }


    [TestMethod]
    public void Parse()
    {
        var parameters = new[]
        {
            (value: <#= x.EnumType #>.MinValue, name: nameof(<#= x.EnumType #>.MinValue), valueString: ((<#= x.UnderlyingType #>)<#= x.EnumType #>.MinValue).ToString(CultureInfo.InvariantCulture)),
<# if (x.IsSignedType) { #>
            (value: <#= x.EnumType #>.Zero,     name: nameof(<#= x.EnumType #>.Zero),     valueString: ((<#= x.UnderlyingType #>)<#= x.EnumType #>.Zero).ToString(CultureInfo.InvariantCulture)),
<# } #>
            (value: <#= x.EnumType #>.MaxValue, name: nameof(<#= x.EnumType #>.MaxValue), valueString: ((<#= x.UnderlyingType #>)<#= x.EnumType #>.MaxValue).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.Parse<<#= x.EnumType #>, <#= x.BoosterType #>>(x.name).Should().Be(x.value);
            FluentActions.Invoking(() => FastEnum.Parse<<#= x.EnumType #>, <#= x.BoosterType #>>(x.name.ToLower(CultureInfo.InvariantCulture))).Should().Throw<ArgumentException>();
            FluentActions.Invoking(() => FastEnum.Parse<<#= x.EnumType #>, <#= x.BoosterType #>>(x.name.ToUpper(CultureInfo.InvariantCulture))).Should().Throw<ArgumentException>();
            FastEnum.Parse<<#= x.EnumType #>, <#= x.BoosterType #>>(x.valueString).Should().Be(x.value);
            FastEnum.Parse<<#= x.EnumType #>, <#= x.BoosterType #>>(x.valueString.ToLower(CultureInfo.InvariantCulture)).Should().Be(x.value);
            FastEnum.Parse<<#= x.EnumType #>, <#= x.BoosterType #>>(x.valueString.ToUpper(CultureInfo.InvariantCulture)).Should().Be(x.value);
        }
        FluentActions.Invoking(static () => FastEnum.Parse<<#= x.EnumType #>, <#= x.BoosterType #>>((string?)null, true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<<#= x.EnumType #>, <#= x.BoosterType #>>("")).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<<#= x.EnumType #>, <#= x.BoosterType #>>(" ")).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<<#= x.EnumType #>, <#= x.BoosterType #>>("ABCDE")).Should().Throw<ArgumentException>();
        FastEnum.Parse<<#= x.EnumType #>, <#= x.BoosterType #>>("123").Should().Be((<#= x.EnumType #>)123);
    }


    [TestMethod]
    public void ParseIgnoreCase()
    {
        var parameters = new[]
        {
            (value: <#= x.EnumType #>.MinValue, name: nameof(<#= x.EnumType #>.MinValue), valueString: ((<#= x.UnderlyingType #>)<#= x.EnumType #>.MinValue).ToString(CultureInfo.InvariantCulture)),
<# if (x.IsSignedType) { #>
            (value: <#= x.EnumType #>.Zero,     name: nameof(<#= x.EnumType #>.Zero),     valueString: ((<#= x.UnderlyingType #>)<#= x.EnumType #>.Zero).ToString(CultureInfo.InvariantCulture)),
<# } #>
            (value: <#= x.EnumType #>.MaxValue, name: nameof(<#= x.EnumType #>.MaxValue), valueString: ((<#= x.UnderlyingType #>)<#= x.EnumType #>.MaxValue).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.Parse<<#= x.EnumType #>, <#= x.BoosterType #>>(x.name, true).Should().Be(x.value);
            FastEnum.Parse<<#= x.EnumType #>, <#= x.BoosterType #>>(x.name.ToLower(CultureInfo.InvariantCulture), true).Should().Be(x.value);
            FastEnum.Parse<<#= x.EnumType #>, <#= x.BoosterType #>>(x.name.ToUpper(CultureInfo.InvariantCulture), true).Should().Be(x.value);
            FastEnum.Parse<<#= x.EnumType #>, <#= x.BoosterType #>>(x.valueString).Should().Be(x.value);
            FastEnum.Parse<<#= x.EnumType #>, <#= x.BoosterType #>>(x.valueString.ToLower(CultureInfo.InvariantCulture), true).Should().Be(x.value);
            FastEnum.Parse<<#= x.EnumType #>, <#= x.BoosterType #>>(x.valueString.ToUpper(CultureInfo.InvariantCulture), true).Should().Be(x.value);
        }
        FluentActions.Invoking(static () => FastEnum.Parse<<#= x.EnumType #>, <#= x.BoosterType #>>((string?)null, true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<<#= x.EnumType #>, <#= x.BoosterType #>>("", true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<<#= x.EnumType #>, <#= x.BoosterType #>>(" ", true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<<#= x.EnumType #>, <#= x.BoosterType #>>("ABCDE", true)).Should().Throw<ArgumentException>();
        FastEnum.Parse<<#= x.EnumType #>, <#= x.BoosterType #>>("123").Should().Be((<#= x.EnumType #>)123);
    }


    [TestMethod]
    public void TryParse()
    {
        var parameters = new[]
        {
            (value: <#= x.EnumType #>.MinValue, name: nameof(<#= x.EnumType #>.MinValue), valueString: ((<#= x.UnderlyingType #>)<#= x.EnumType #>.MinValue).ToString(CultureInfo.InvariantCulture)),
<# if (x.IsSignedType) { #>
            (value: <#= x.EnumType #>.Zero,     name: nameof(<#= x.EnumType #>.Zero),     valueString: ((<#= x.UnderlyingType #>)<#= x.EnumType #>.Zero).ToString(CultureInfo.InvariantCulture)),
<# } #>
            (value: <#= x.EnumType #>.MaxValue, name: nameof(<#= x.EnumType #>.MaxValue), valueString: ((<#= x.UnderlyingType #>)<#= x.EnumType #>.MaxValue).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.TryParse<<#= x.EnumType #>, <#= x.BoosterType #>>(x.name, out var r1).Should().BeTrue();
            r1.Should().Be(x.value);

            FastEnum.TryParse<<#= x.EnumType #>, <#= x.BoosterType #>>(x.name.ToLower(CultureInfo.InvariantCulture), out var _).Should().BeFalse();
            FastEnum.TryParse<<#= x.EnumType #>, <#= x.BoosterType #>>(x.name.ToUpper(CultureInfo.InvariantCulture), out var _).Should().BeFalse();

            FastEnum.TryParse<<#= x.EnumType #>, <#= x.BoosterType #>>(x.valueString, out var r2).Should().BeTrue();
            r2.Should().Be(x.value);

            FastEnum.TryParse<<#= x.EnumType #>, <#= x.BoosterType #>>(x.valueString.ToLower(CultureInfo.InvariantCulture), out var r3).Should().BeTrue();
            r3.Should().Be(x.value);

            FastEnum.TryParse<<#= x.EnumType #>, <#= x.BoosterType #>>(x.valueString.ToUpper(CultureInfo.InvariantCulture), out var r4).Should().BeTrue();
            r4.Should().Be(x.value);
        }
        FastEnum.TryParse<<#= x.EnumType #>, <#= x.BoosterType #>>((string?)null, out var _).Should().BeFalse();
        FastEnum.TryParse<<#= x.EnumType #>, <#= x.BoosterType #>>("", out var _).Should().BeFalse();
        FastEnum.TryParse<<#= x.EnumType #>, <#= x.BoosterType #>>(" ", out var _).Should().BeFalse();
        FastEnum.TryParse<<#= x.EnumType #>, <#= x.BoosterType #>>("ABCDE", out var _).Should().BeFalse();
        FastEnum.TryParse<<#= x.EnumType #>, <#= x.BoosterType #>>("123", out var r).Should().BeTrue();
        r.Should().Be((<#= x.EnumType #>)123);
    }


    [TestMethod]
    public void TryParseIgnoreCase()
    {
        var parameters = new[]
        {
            (value: <#= x.EnumType #>.MinValue, name: nameof(<#= x.EnumType #>.MinValue), valueString: ((<#= x.UnderlyingType #>)<#= x.EnumType #>.MinValue).ToString(CultureInfo.InvariantCulture)),
<# if (x.IsSignedType) { #>
            (value: <#= x.EnumType #>.Zero,     name: nameof(<#= x.EnumType #>.Zero),     valueString: ((<#= x.UnderlyingType #>)<#= x.EnumType #>.Zero).ToString(CultureInfo.InvariantCulture)),
<# } #>
            (value: <#= x.EnumType #>.MaxValue, name: nameof(<#= x.EnumType #>.MaxValue), valueString: ((<#= x.UnderlyingType #>)<#= x.EnumType #>.MaxValue).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.TryParse<<#= x.EnumType #>, <#= x.BoosterType #>>(x.name, true, out var r1).Should().BeTrue();
            r1.Should().Be(x.value);

            FastEnum.TryParse<<#= x.EnumType #>, <#= x.BoosterType #>>(x.name.ToLower(CultureInfo.InvariantCulture), true, out var r2).Should().BeTrue();
            r2.Should().Be(x.value);

            FastEnum.TryParse<<#= x.EnumType #>, <#= x.BoosterType #>>(x.name.ToUpper(CultureInfo.InvariantCulture), true, out var r3).Should().BeTrue();
            r3.Should().Be(x.value);

            FastEnum.TryParse<<#= x.EnumType #>, <#= x.BoosterType #>>(x.valueString, true, out var r4).Should().BeTrue();
            r4.Should().Be(x.value);

            FastEnum.TryParse<<#= x.EnumType #>, <#= x.BoosterType #>>(x.valueString.ToLower(CultureInfo.InvariantCulture), true, out var r5).Should().BeTrue();
            r5.Should().Be(x.value);

            FastEnum.TryParse<<#= x.EnumType #>, <#= x.BoosterType #>>(x.valueString.ToUpper(CultureInfo.InvariantCulture), true, out var r6).Should().BeTrue();
            r6.Should().Be(x.value);
        }
        FastEnum.TryParse<<#= x.EnumType #>, <#= x.BoosterType #>>((string?)null, true, out var _).Should().BeFalse();
        FastEnum.TryParse<<#= x.EnumType #>, <#= x.BoosterType #>>("", true, out var _).Should().BeFalse();
        FastEnum.TryParse<<#= x.EnumType #>, <#= x.BoosterType #>>(" ", true, out var _).Should().BeFalse();
        FastEnum.TryParse<<#= x.EnumType #>, <#= x.BoosterType #>>("ABCDE", true, out var _).Should().BeFalse();
        FastEnum.TryParse<<#= x.EnumType #>, <#= x.BoosterType #>>("123", true, out var r).Should().BeTrue();
        r.Should().Be((<#= x.EnumType #>)123);
    }


    [TestMethod]
    public void FastToString()
    {
        const <#= x.EnumType #> undefined = (<#= x.EnumType #>)123;
        var values = Enum.GetValues<<#= x.EnumType #>>().Append(undefined);
        foreach (var x in values)
        {
            var expect = x.ToString();
            var actual = FastEnum.ToString<<#= x.EnumType #>, <#= x.BoosterType #>>(x);
            actual.Should().Be(expect);
        }
    }
}



<# } #>